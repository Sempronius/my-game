<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Side-Scrolling Platformer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #1a1a2e;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      border: 2px solid #333;
      image-rendering: pixelated;
    }
    #ui-overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-family: monospace;
      font-size: 14px;
      pointer-events: none;
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="ui-overlay"></div>
  <canvas id="gameCanvas"></canvas>

  <script>
// =============================================================================
// CANVAS SETUP
// =============================================================================

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui-overlay");

canvas.width = 800;
canvas.height = 500;

// =============================================================================
// GAME CONSTANTS
// =============================================================================

const GRAVITY = 0.6;           // Downward acceleration per frame
const JUMP_FORCE = -15;        // Upward velocity when jumping (negative = up)
const MOVE_SPEED = 5;          // Horizontal movement speed
const FRICTION = 0.8;          // Horizontal deceleration (1 = no friction)
const MAX_FALL_SPEED = 15;     // Terminal velocity cap

const PROJECTILE_SPEED = 9;    // Horizontal speed of projectiles
const PROJECTILE_SIZE = 10;    // Placeholder size (square dot)
const SHOOT_COOLDOWN = 15;     // Frames between shots (~0.25s at 60fps)

const BOSS_JUMP_FORCE = -11;          // Boss jump strength
const BOSS_SHOOT_INTERVAL_MIN = 90;   // Min frames between boss shots
const BOSS_SHOOT_INTERVAL_MAX = 180;  // Max frames between boss shots
const BOSS_JUMP_INTERVAL_MIN = 120;   // Min frames between boss jumps
const BOSS_JUMP_INTERVAL_MAX = 240;   // Max frames between boss jumps
const BOSS_BLASTER_SPEED = 5;         // Speed of boss projectiles

const PLAYER_INVINCIBLE_TIME = 60;    // Frames of invincibility after hit
const PLAYER_HP_BAR_DURATION = 180;   // Frames to show health bar (~3s)

// Fallback sky color shown while background image loads or if it fails
const SKY_COLOR = "#5dadec";

// =============================================================================
// ASSET LOADING
// Load all images before starting the game. Each entry tracks whether the
// image loaded successfully so we can fall back to rectangles if needed.
// =============================================================================

const assets = {
  player:          { img: new Image(), loaded: false, frames: [] },
  enemy:           { img: new Image(), loaded: false, frames: [] },
  background:      { img: new Image(), loaded: false },
  portal:          { img: new Image(), loaded: false },
  background2:     { img: new Image(), loaded: false },
  boss:            { img: new Image(), loaded: false, frames: [] },
  car:             { img: new Image(), loaded: false },
  secretDoor:      { img: new Image(), loaded: false },
  secretDoorBroken:{ img: new Image(), loaded: false },
  secretCave:      { img: new Image(), loaded: false, frames: [] },
  poodle:          { img: new Image(), loaded: false, frames: [] },
  poodleTalk:      { img: new Image(), loaded: false, frames: [] },
  sword:           { img: new Image(), loaded: false, frames: [] },
  poodleCar:       { img: new Image(), loaded: false },
};

/** Returns a Promise that resolves once an image loads (or fails gracefully) */
function loadImage(asset, src) {
  return new Promise((resolve) => {
    asset.img.onload = () => { asset.loaded = true; resolve(); };
    asset.img.onerror = () => {
      console.warn(`Could not load "${src}" — using fallback rectangle.`);
      resolve(); // Don't block the game if an image is missing
    };
    asset.img.src = src;
  });
}

/** Load numbered animation frames (e.g. player_j1.png, player_j2.png, ...) */
async function loadAnimFrames(asset, baseSrc) {
  asset.frames = asset.loaded ? [asset.img] : [];
  if (!asset.loaded) return;
  const prefix = baseSrc.replace(".png", "");
  const bust = "?t=" + Date.now();
  // Load all numbered frames 1-200, skipping gaps (files may be non-sequential)
  const probes = [];
  for (let n = 1; n <= 200; n++) {
    const img = new Image();
    probes.push(new Promise((resolve) => {
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = prefix + n + ".png" + bust;
    }));
  }
  const results = await Promise.all(probes);
  for (const img of results) {
    if (img) asset.frames.push(img);
  }
}

// =============================================================================
// PROCEDURAL POODLE SPRITES (generated from code — no image files needed)
// =============================================================================

/** Convert an offscreen canvas to an Image (so naturalWidth/naturalHeight work) */
function canvasToImg(cv) {
  return new Promise(r => { const i = new Image(); i.onload = () => r(i); i.src = cv.toDataURL(); });
}

/** Draw a single 48x48 poodle frame on a fresh canvas, return the canvas */
function poodleFrame(drawFn) {
  const cv = document.createElement("canvas");
  cv.width = 48; cv.height = 48;
  const cx = cv.getContext("2d");
  const p = (ox, oy, w, h, col) => { cx.fillStyle = col; cx.fillRect(ox, oy, w, h); };
  drawFn(p);
  return cv;
}

// Shared color palette
const PC = {
  lg: "#f4d99f", mg: "#e8c170", dg: "#d4a843",
  br: "#8b5a2b", db: "#654321", cr: "#fff5cc", yl: "#ffd700",
  pk: "#ffb6c1", dp: "#ff69b4"
};

/** Common poodle head + body drawing (used by most frames) */
function poodleBase(p, yOff) {
  const y = yOff || 0;
  p(16, 4+y, 16, 4, PC.yl);
  p(14, 8+y, 20, 4, PC.lg);
  p(12, 12+y, 24, 4, PC.mg);
  p(10, 12+y, 4, 8, PC.dg); // ears
  p(34, 12+y, 4, 8, PC.dg);
  p(14, 16+y, 20, 8, PC.cr); // face
  p(18, 18+y, 3, 2, PC.db); // eyes
  p(27, 18+y, 3, 2, PC.db);
  p(22, 22+y, 4, 2, PC.br); // nose
  p(16, 24+y, 16, 12, PC.mg); // body
  p(14, 26+y, 20, 8, PC.lg);
}

/** Generate poodle WALKING frames (6 frames, 48x48 each) */
async function generatePoodleWalkFrames() {
  const canvases = [
    // Frame 0: Standing
    poodleFrame(p => {
      poodleBase(p, 0);
      p(18,36,4,8,PC.dg); p(26,36,4,8,PC.dg); p(14,36,4,8,PC.dg); p(30,36,4,8,PC.dg);
      p(18,44,4,2,PC.br); p(26,44,4,2,PC.br); p(14,44,4,2,PC.br); p(30,44,4,2,PC.br);
      p(6,28,6,6,PC.yl); p(4,30,8,4,PC.lg);
    }),
    // Frame 1: Bob +1, legs phase A
    poodleFrame(p => {
      poodleBase(p, 1);
      p(18,37,4,7,PC.dg); p(18,44,4,2,PC.br);
      p(26,36,4,8,PC.dg); p(26,44,4,2,PC.br);
      p(14,37,4,7,PC.dg); p(14,44,4,2,PC.br);
      p(30,36,4,8,PC.dg); p(30,44,4,2,PC.br);
      p(6,27,6,6,PC.yl); p(4,29,8,4,PC.lg);
    }),
    // Frame 2: Legs spread more
    poodleFrame(p => {
      poodleBase(p, 0);
      p(20,38,4,6,PC.dg); p(20,44,4,2,PC.br);
      p(24,36,4,8,PC.dg); p(24,44,4,2,PC.br);
      p(13,38,4,6,PC.dg); p(13,44,4,2,PC.br);
      p(31,36,4,8,PC.dg); p(31,44,4,2,PC.br);
      p(6,28,6,6,PC.yl); p(4,30,8,4,PC.lg);
    }),
    // Frame 3: Bob +1, opposite legs
    poodleFrame(p => {
      poodleBase(p, 1);
      p(18,36,4,8,PC.dg); p(18,44,4,2,PC.br);
      p(26,37,4,7,PC.dg); p(26,44,4,2,PC.br);
      p(14,36,4,8,PC.dg); p(14,44,4,2,PC.br);
      p(30,37,4,7,PC.dg); p(30,44,4,2,PC.br);
      p(6,29,6,6,PC.yl); p(4,31,8,4,PC.lg);
    }),
    // Frame 4: Spread opposite
    poodleFrame(p => {
      poodleBase(p, 0);
      p(16,36,4,8,PC.dg); p(16,44,4,2,PC.br);
      p(28,38,4,6,PC.dg); p(28,44,4,2,PC.br);
      p(15,36,4,8,PC.dg); p(15,44,4,2,PC.br);
      p(29,38,4,6,PC.dg); p(29,44,4,2,PC.br);
      p(5,27,6,6,PC.yl); p(3,29,8,4,PC.lg);
    }),
    // Frame 5: Bob +1, return phase
    poodleFrame(p => {
      poodleBase(p, 1);
      p(18,36,4,8,PC.dg); p(18,44,4,2,PC.br);
      p(26,37,4,7,PC.dg); p(26,44,4,2,PC.br);
      p(14,37,4,7,PC.dg); p(14,44,4,2,PC.br);
      p(30,36,4,8,PC.dg); p(30,44,4,2,PC.br);
      p(7,28,6,6,PC.yl); p(5,30,8,4,PC.lg);
    }),
  ];
  return Promise.all(canvases.map(canvasToImg));
}

/** Generate poodle TALKING frames (6 frames, 48x48 each) */
async function generatePoodleTalkFrames() {
  function talkBase(p, mouth) {
    poodleBase(p, 0);
    mouth(p);
    // Standing legs (no walk)
    p(18,36,4,8,PC.dg); p(26,36,4,8,PC.dg); p(14,36,4,8,PC.dg); p(30,36,4,8,PC.dg);
    p(18,44,4,2,PC.br); p(26,44,4,2,PC.br); p(14,44,4,2,PC.br); p(30,44,4,2,PC.br);
  }
  const canvases = [
    // Frame 0: Mouth closed
    poodleFrame(p => {
      talkBase(p, p2 => { p2(23,24,2,1,PC.db); });
      p(6,28,6,6,PC.yl); p(4,30,8,4,PC.lg);
    }),
    // Frame 1: Mouth slightly open
    poodleFrame(p => {
      talkBase(p, p2 => { p2(22,24,4,2,PC.db); p2(23,25,2,1,PC.pk); });
      p(6,28,6,6,PC.yl); p(4,30,8,4,PC.lg);
    }),
    // Frame 2: Mouth more open
    poodleFrame(p => {
      talkBase(p, p2 => { p2(21,24,6,3,PC.db); p2(22,25,4,2,PC.pk); });
      p(5,28,6,6,PC.yl); p(3,30,8,4,PC.lg);
    }),
    // Frame 3: Mouth fully open (tongue)
    poodleFrame(p => {
      talkBase(p, p2 => { p2(20,24,8,4,PC.db); p2(21,25,6,3,PC.pk); p2(23,26,2,1,PC.dp); });
      p(7,28,6,6,PC.yl); p(5,30,8,4,PC.lg);
    }),
    // Frame 4: Mouth closing (= frame 2)
    poodleFrame(p => {
      talkBase(p, p2 => { p2(21,24,6,3,PC.db); p2(22,25,4,2,PC.pk); });
      p(6,28,6,6,PC.yl); p(4,30,8,4,PC.lg);
    }),
    // Frame 5: Mouth almost closed (= frame 1)
    poodleFrame(p => {
      talkBase(p, p2 => { p2(22,24,4,2,PC.db); p2(23,25,2,1,PC.pk); });
      p(5,28,6,6,PC.yl); p(3,30,8,4,PC.lg);
    }),
  ];
  return Promise.all(canvases.map(canvasToImg));
}

/**
 * Load all assets, show a loading screen, then start the game.
 * Images are in the same folder as index.html.
 */
async function loadAllAssets() {
  // Show loading text
  ctx.fillStyle = "#1a1a2e";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = "white";
  ctx.font = "20px monospace";
  ctx.textAlign = "center";
  ctx.fillText("Loading assets...", canvas.width / 2, canvas.height / 2);
  ctx.textAlign = "left";

  // --- Design 2 (_j suffix) --- Assets organized in subdirectories
  await Promise.all([
    loadImage(assets.player,          "assets/player/player_j.png"),
    loadImage(assets.enemy,           "assets/enemy/enemy_j.png"),
    loadImage(assets.background,      "assets/backgrounds/background_j.png"),
    loadImage(assets.portal,          "assets/portal/portal_j.png"),
    loadImage(assets.background2,     "assets/backgrounds/background2_j.png"),
    loadImage(assets.boss,            "assets/boss/boss_j.png"),
    loadImage(assets.car,             "assets/player/car.png"),
    loadImage(assets.secretDoor,      "assets/secret_door/secret_door_j.png"),
    loadImage(assets.secretDoorBroken,"assets/secret_door/secret_door_broken_j.png"),
    loadImage(assets.secretCave,      "assets/backgrounds/secret_cave_j.png"),
    // poodle + poodleTalk generated from code below (no PNG needed)
    loadImage(assets.sword,           "assets/sword/sword_j.png"),
    loadImage(assets.poodleCar,       "assets/poodle/poodle_car_j.png"),
  ]);

  // Load animation frames (numbered variants like player_j1.png, player_j2.png, ...)
  await Promise.all([
    loadAnimFrames(assets.player,     "assets/player/player_j.png"),
    loadAnimFrames(assets.enemy,      "assets/enemy/enemy_j.png"),
    loadAnimFrames(assets.boss,       "assets/boss/boss_j.png"),
    loadAnimFrames(assets.secretCave, "assets/backgrounds/secret_cave_j.png"),
    // poodle + poodleTalk use procedural frames (no PNG loading)
    loadAnimFrames(assets.sword,      "assets/sword/sword_j.png"),
  ]);

  // Generate poodle sprites from code (no PNG files needed)
  assets.poodle.frames = await generatePoodleWalkFrames();
  assets.poodle.loaded = true;
  assets.poodle.img = assets.poodle.frames[0];
  assets.poodleTalk.frames = await generatePoodleTalkFrames();
  assets.poodleTalk.loaded = true;
  assets.poodleTalk.img = assets.poodleTalk.frames[0];

  // Load Level 1 and start the game loop
  loadLevel(0);
  gameLoop();
}

// =============================================================================
// INPUT HANDLING
// Track which keys are currently held down
// =============================================================================

const keys = {};

window.addEventListener("keydown", (e) => {
  keys[e.code] = true;
  // Discrete aim rotation: each press steps the angle by 15°
  if (e.code === "Comma")  player.aimAngle -= Math.PI / 12;
  if (e.code === "Period") player.aimAngle += Math.PI / 12;
  if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space", "ShiftLeft", "ShiftRight", "Comma", "Period"].includes(e.code)) {
    e.preventDefault();
  }
});

window.addEventListener("keyup", (e) => {
  keys[e.code] = false;
});

// =============================================================================
// CAMERA
// The camera follows the player horizontally with a smooth offset.
// =============================================================================

const camera = {
  x: 0,
  y: 0,

  /** Keep the player roughly 1/3 from the left side of the screen */
  follow(target) {
    this.x = target.x - canvas.width * 0.33;
    // Prevent camera from going left of the level start
    if (this.x < 0) this.x = 0;
  }
};

// =============================================================================
// PLAYER
// =============================================================================

const PLAYER_BASE_W = 60;
const PLAYER_BASE_H = 80;

const player = {
  x: 100,               // World position
  y: 300,
  width: PLAYER_BASE_W,
  height: PLAYER_BASE_H,
  velX: 0,              // Horizontal velocity
  velY: 0,              // Vertical velocity
  onGround: false,      // Whether we're standing on something
  color: "#e63946",     // Placeholder color — replace with sprite later
  facing: 1,            // 1 = right, -1 = left (useful for sprite flipping)
  hp: 12,               // Player health (2x boss HP)
  maxHp: 12,
  invincibleTimer: 0,   // Frames of invincibility after being hit
  hpBarTimer: 0,        // Countdown for showing health bar
  animFrame: 0,         // Current animation frame index
  animTimer: 0,         // Ticks until next frame advance
  aimAngle: 0,          // Shooting angle relative to facing direction (radians)
  beamActive: false,    // Sword beam currently firing
  beamAngle: 0,         // Beam fire angle

  /** Reset the player back to the start */
  reset() {
    this.x = 100;
    this.y = 300;
    this.velX = 0;
    this.velY = 0;
    this.onGround = false;
    this.hp = this.maxHp;
    this.invincibleTimer = 0;
    this.hpBarTimer = 0;
    this.animFrame = 0;
    this.animTimer = 0;
    this.aimAngle = 0;
    this.beamActive = false;
    this.beamAngle = 0;
    stopBeamSound();
  },

  update() {
    // Don't allow input during transitions or victory
    if (transitionTimer > 0 || victoryScreen) return;

    // ---- Auto-size hitbox to match sprite aspect ratio ----
    if (isPoodle) {
      const pa = assets.poodle;
      const src = pa.frames.length > 0 ? pa.frames[0] : (pa.loaded ? pa.img : null);
      if (src && src.naturalWidth && src.naturalHeight) {
        const ratio = src.naturalWidth / src.naturalHeight;
        this.height = PLAYER_BASE_H;
        this.width = Math.round(PLAYER_BASE_H * ratio);
      }
    } else {
      this.width = PLAYER_BASE_W;
      this.height = PLAYER_BASE_H;
    }

    // ---- Invincibility & HP bar timers ----
    if (this.invincibleTimer > 0) this.invincibleTimer--;
    if (this.hpBarTimer > 0) this.hpBarTimer--;

    // ---- Horizontal movement ----
    const moving = keys["ArrowLeft"] || keys["ArrowRight"];
    if (keys["ArrowLeft"]) {
      this.velX = -MOVE_SPEED;
      this.facing = -1;
    } else if (keys["ArrowRight"]) {
      this.velX = MOVE_SPEED;
      this.facing = 1;
    } else {
      // Decelerate when no key is pressed
      this.velX *= FRICTION;
      if (Math.abs(this.velX) < 0.5) this.velX = 0;
    }

    // Engine rumble: start when moving in corvette mode, stop otherwise
    if (corvetteMode && moving) {
      startEngine();
    } else {
      stopEngine();
    }

    // ---- Walk animation ----
    const animAsset = isPoodle ? assets.poodle : assets.player;
    if (animAsset.frames.length > 1) {
      const animSpeed = moving ? (isPoodle ? 9 : 12) : 24; // poodle: 150ms, player: 200ms
      this.animTimer++;
      if (this.animTimer >= animSpeed) {
        this.animTimer = 0;
        this.animFrame = (this.animFrame + 1) % animAsset.frames.length;
      }
    }

    // ---- Jumping ----
    if ((keys["ArrowUp"] || keys["Space"]) && this.onGround) {
      this.velY = JUMP_FORCE;
      this.onGround = false;
      playSound(corvetteMode ? "car_jump" : "jump");
    }

    // ---- Aiming (angle set by keydown handler, persists between presses) ----
    const fireAngle = this.facing === 1 ? this.aimAngle : Math.PI - this.aimAngle;

    // ---- Shooting: Shift fires in aimed direction ----
    if (shootCooldown > 0) shootCooldown--;
    const shifting = keys["ShiftLeft"] || keys["ShiftRight"];

    if (hasSword && shifting) {
      // Continuous beam weapon (sword equipped)
      this.beamActive = true;
      this.beamAngle = fireAngle;
      startBeamSound();
    } else {
      if (this.beamActive) stopBeamSound();
      this.beamActive = false;

      if (shifting && shootCooldown === 0) {
        if (corvetteMode) {
          // Triple laser fan
          for (const spread of [-1, 0, 1]) {
            const sa = fireAngle + spread * 0.15;
            projectiles.push({
              x: this.x + this.width / 2 - PROJECTILE_SIZE / 2,
              y: this.y + this.height / 2 - PROJECTILE_SIZE / 2,
              velX: Math.cos(sa) * PROJECTILE_SPEED,
              velY: Math.sin(sa) * PROJECTILE_SPEED,
              angle: sa,
              facing: this.facing,
              age: 0,
              trail: [],
              spread: spread,
            });
          }
          playSound("shoot_triple");
        } else {
          projectiles.push({
            x: this.x + this.width / 2 - PROJECTILE_SIZE / 2,
            y: this.y + this.height / 2 - PROJECTILE_SIZE / 2,
            velX: Math.cos(fireAngle) * PROJECTILE_SPEED,
            velY: Math.sin(fireAngle) * PROJECTILE_SPEED,
            angle: fireAngle,
            facing: this.facing,
            age: 0,
            trail: [],
            spread: 0,
          });
          playSound("shoot");
        }
        shootCooldown = SHOOT_COOLDOWN;
      }
    }

    // ---- Gravity ----
    this.velY += GRAVITY;
    if (this.velY > MAX_FALL_SPEED) this.velY = MAX_FALL_SPEED;

    // ---- Apply movement ----
    this.x += this.velX;
    this.y += this.velY;

    // ---- World bounds ----
    // Don't let the player walk off the left edge
    if (this.x < 0) {
      this.x = 0;
      this.velX = 0;
    }

    // If the player falls below the screen, they die
    if (this.y > canvas.height + 100) {
      die();
    }
  },

  draw() {
    const screenX = this.x - camera.x;
    const screenY = this.y - camera.y;

    // Flash during invincibility (skip drawing every other 4-frame block)
    if (this.invincibleTimer > 0 && Math.floor(this.invincibleTimer / 4) % 2 === 0) {
      return;
    }

    // ---- Corvette mode: draw car around player ----
    if (corvetteMode) {
      const carW = 100;
      const carH = 36;
      const carX = screenX + this.width / 2 - carW / 2;
      const carY = screenY + this.height - carH - 2;

      // Use poodle car if in poodle mode
      const carAsset = (isPoodle && poodleMode && assets.poodleCar.loaded) ? assets.poodleCar : assets.car;

      if (carAsset.loaded) {
        ctx.save();
        if (this.facing === 1) {
          ctx.translate(carX + carW, carY);
          ctx.scale(-1, 1);
          ctx.drawImage(carAsset.img, 0, 0, carW, carH);
        } else {
          ctx.drawImage(carAsset.img, carX, carY, carW, carH);
        }
        ctx.restore();
      } else {
        ctx.save();
        if (this.facing === -1) {
          ctx.translate(screenX + this.width / 2, 0);
          ctx.scale(-1, 1);
          ctx.translate(-(screenX + this.width / 2), 0);
        }
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(carX + 5, carY + carH - 2, carW - 10, 6);
        ctx.fillStyle = isPoodle ? "#f9a8d4" : "#cc0000";
        ctx.fillRect(carX + 4, carY + 4, carW - 8, carH - 8);
        ctx.fillStyle = "#222";
        ctx.beginPath();
        ctx.arc(carX + 18, carY + carH - 4, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(carX + carW - 18, carY + carH - 4, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // ---- Choose sprite: poodle or player ----
    const spriteAsset = isPoodle ? assets.poodle : assets.player;
    const spriteLoaded = isPoodle ? (assets.poodle.loaded || assets.poodle.frames.length > 0) : assets.player.loaded;

    // ---- Draw player/poodle sprite (head sticks out above corvette) ----
    if (spriteLoaded) {
      const pImg = spriteAsset.frames.length > 1 ? spriteAsset.frames[this.animFrame % spriteAsset.frames.length] : spriteAsset.img;
      ctx.save();
      if (this.facing === -1) {
        ctx.translate(screenX + this.width, screenY);
        ctx.scale(-1, 1);
        if (corvetteMode) {
          ctx.drawImage(pImg,
            0, 0, pImg.naturalWidth, pImg.naturalHeight * 0.5,
            0, 0, this.width, this.height * 0.5);
        } else {
          ctx.drawImage(pImg, 0, 0, this.width, this.height);
        }
      } else {
        if (corvetteMode) {
          ctx.drawImage(pImg,
            0, 0, pImg.naturalWidth, pImg.naturalHeight * 0.5,
            screenX, screenY, this.width, this.height * 0.5);
        } else {
          ctx.drawImage(pImg, screenX, screenY, this.width, this.height);
        }
      }
      ctx.restore();
    } else {
      // Fallback: colored rectangle with eyes
      const fallbackColor = isPoodle ? "#f9a8d4" : this.color;
      if (corvetteMode) {
        ctx.fillStyle = fallbackColor;
        ctx.fillRect(screenX, screenY, this.width, this.height * 0.5);
        ctx.fillStyle = "white";
        const eyeOffsetX = this.facing === 1 ? 28 : 8;
        ctx.fillRect(screenX + eyeOffsetX, screenY + 8, 12, 12);
        ctx.fillStyle = "#1a1a2e";
        const pupilOffsetX = this.facing === 1 ? 34 : 8;
        ctx.fillRect(screenX + pupilOffsetX, screenY + 12, 6, 6);
      } else {
        ctx.fillStyle = fallbackColor;
        ctx.fillRect(screenX, screenY, this.width, this.height);
        ctx.fillStyle = "white";
        const eyeOffsetX = this.facing === 1 ? 28 : 8;
        ctx.fillRect(screenX + eyeOffsetX, screenY + 16, 12, 12);
        ctx.fillStyle = "#1a1a2e";
        const pupilOffsetX = this.facing === 1 ? 34 : 8;
        ctx.fillRect(screenX + pupilOffsetX, screenY + 20, 6, 6);
      }
    }

    // ---- Sword in player's raised right hand ----
    if (hasSword && !corvetteMode) {
      const swordW = 32;
      const swordH = 64;
      // Hand position: upper-right of sprite (right arm raised)
      const handX = this.facing === 1 ? this.width - 12 : 12 - swordW;
      const handY = -swordH + 24; // sword extends above head, handle near hand
      // Animate sword frames
      const swordAsset = assets.sword;
      const swordImg = swordAsset.frames.length > 1
        ? swordAsset.frames[this.animFrame % swordAsset.frames.length]
        : swordAsset.img;

      if (swordAsset.loaded || swordAsset.frames.length > 0) {
        ctx.drawImage(swordImg, screenX + handX, screenY + handY, swordW, swordH);
      } else {
        ctx.fillStyle = "#fbbf24";
        ctx.fillRect(screenX + handX + swordW / 2 - 3, screenY + handY, 6, swordH - 12);
        ctx.fillStyle = "#8b6914";
        ctx.fillRect(screenX + handX, screenY + handY + swordH - 14, swordW, 6);
      }
    }

  }
};

// =============================================================================
// LEVEL DATA
// Each level defines platforms, enemies, decorations, background, portal, boss.
// =============================================================================

const levels = [
  // ---- LEVEL 1 ----
  {
    backgroundKey: "background",
    platforms: [
      // Ground segments
      { x: 0,    y: 450, width: 3200, height: 50, color: "#4a1a1a" },

      // Floating platforms at various heights
      { x: 250,  y: 330, width: 150,  height: 20, color: "#6b2d2d" },
      { x: 500,  y: 280, width: 180,  height: 20, color: "#723333" },
      { x: 780,  y: 340, width: 140,  height: 20, color: "#6b2d2d" },
      { x: 1000, y: 260, width: 200,  height: 20, color: "#7a3838" },

      // Gap in the ground — bridged by floating platforms
      { x: 1350, y: 450, width: 800,  height: 50, color: "#4a1a1a" },

      { x: 1200, y: 330, width: 120,  height: 20, color: "#723333" },
      { x: 1500, y: 300, width: 160,  height: 20, color: "#6b2d2d" },
      { x: 1750, y: 330, width: 140,  height: 20, color: "#7a3838" },
      { x: 2000, y: 280, width: 180,  height: 20, color: "#6b2d2d" },

      // Final ground stretch with portal
      { x: 2300, y: 450, width: 1000, height: 50, color: "#4a1a1a" },

      { x: 2400, y: 340, width: 150,  height: 20, color: "#723333" },
      { x: 2700, y: 260, width: 160,  height: 20, color: "#6b2d2d" },
    ],
    enemies: [
      {
        x: 520, y: 184, width: 84, height: 96,
        speed: 1.0, direction: 1, minX: 500, maxX: 680, color: "#9b2226",
        hp: 3, maxHp: 3,
      },
      {
        x: 1520, y: 204, width: 84, height: 96,
        speed: 1.3, direction: -1, minX: 1500, maxX: 1660, color: "#9b2226",
        hp: 3, maxHp: 3,
      },
    ],
    decorations: [
      // Bushes (varied maroon/burgundy tones)
      { x: 150,  y: 410, width: 80,  height: 40, color: "#7a3333", parallax: 0.3 },
      { x: 500,  y: 420, width: 60,  height: 30, color: "#6b2828", parallax: 0.3 },
      { x: 900,  y: 405, width: 100, height: 45, color: "#8b3d3d", parallax: 0.3 },
      { x: 1400, y: 415, width: 70,  height: 35, color: "#723030", parallax: 0.3 },
      { x: 2000, y: 410, width: 90,  height: 40, color: "#7a3333", parallax: 0.3 },
      { x: 2500, y: 420, width: 75,  height: 35, color: "#8b3d3d", parallax: 0.3 },
      // Clouds
      { x: 100,  y: 60,  width: 120, height: 40, color: "rgba(255,255,255,0.6)", parallax: 0.15 },
      { x: 450,  y: 90,  width: 90,  height: 30, color: "rgba(255,255,255,0.5)", parallax: 0.1 },
      { x: 850,  y: 50,  width: 140, height: 45, color: "rgba(255,255,255,0.55)", parallax: 0.12 },
      { x: 1300, y: 75,  width: 100, height: 35, color: "rgba(255,255,255,0.5)", parallax: 0.1 },
      { x: 1800, y: 55,  width: 130, height: 42, color: "rgba(255,255,255,0.6)", parallax: 0.15 },
      { x: 2400, y: 80,  width: 110, height: 38, color: "rgba(255,255,255,0.5)", parallax: 0.12 },
    ],
    portal: { x: 3100, y: 370, width: 48, height: 80 },
    boss: null,
  },

  // ---- LEVEL 2 (Cave / Dungeon) ----
  {
    backgroundKey: "background2",
    platforms: [
      // Starting ground — extended for easier start
      { x: 0,   y: 450, width: 700,  height: 50, color: "#5c4033" },

      // Floating platforms above starting area for variety
      { x: 250, y: 330, width: 120, height: 20, color: "#6b4f3a" },
      { x: 500, y: 300, width: 140, height: 20, color: "#6b4f3a" },

      // First gap (700–850, ~150px — easy jump)
      { x: 850,  y: 450, width: 650,  height: 50, color: "#5c4033" },

      // Floating platforms in mid-section
      { x: 950,  y: 340, width: 120, height: 20, color: "#6b4f3a" },
      { x: 1200, y: 300, width: 130, height: 20, color: "#6b4f3a" },

      // Second gap (1500–1650, ~150px — easy jump)
      { x: 1650, y: 450, width: 450, height: 50, color: "#5c4033" },

      { x: 1750, y: 330, width: 120, height: 20, color: "#6b4f3a" },

      // Boss arena — wide flat ground
      { x: 2100, y: 450, width: 800, height: 50, color: "#5c4033" },

      // Platforms above boss arena for stomping (narrow so boss falls through gaps)
      { x: 2200, y: 300, width: 80, height: 20, color: "#6b4f3a" },
      { x: 2460, y: 280, width: 80, height: 20, color: "#6b4f3a" },
      { x: 2720, y: 300, width: 80, height: 20, color: "#6b4f3a" },
    ],
    enemies: [
      {
        x: 520, y: 204, width: 84, height: 96,
        speed: 1.0, direction: 1, minX: 500, maxX: 640, color: "#9b2226",
        hp: 3, maxHp: 3,
      },
      {
        x: 900, y: 354, width: 84, height: 96,
        speed: 1.3, direction: -1, minX: 850, maxX: 1100, color: "#9b2226",
        hp: 3, maxHp: 3,
      },
      {
        x: 1750, y: 234, width: 84, height: 96,
        speed: 1.2, direction: 1, minX: 1750, maxX: 1870, color: "#9b2226",
        hp: 3, maxHp: 3,
      },
    ],
    decorations: [
      // Stalactites (hanging from ceiling)
      { x: 200,  y: 0,   width: 20,  height: 60,  color: "#7a6652", parallax: 0.3, type: "stalactite" },
      { x: 600,  y: 0,   width: 16,  height: 50,  color: "#7a6652", parallax: 0.3, type: "stalactite" },
      { x: 1000, y: 0,   width: 22,  height: 70,  color: "#7a6652", parallax: 0.3, type: "stalactite" },
      { x: 1500, y: 0,   width: 18,  height: 55,  color: "#7a6652", parallax: 0.3, type: "stalactite" },
      { x: 2300, y: 0,   width: 20,  height: 65,  color: "#7a6652", parallax: 0.3, type: "stalactite" },
      { x: 2600, y: 0,   width: 24,  height: 72,  color: "#7a6652", parallax: 0.3, type: "stalactite" },
      // Glowing crystals on the ground
      { x: 350,  y: 430, width: 16,  height: 20,  color: "#4ecdc4", parallax: 0.3, type: "crystal" },
      { x: 900,  y: 430, width: 12,  height: 18,  color: "#a78bfa", parallax: 0.3, type: "crystal" },
      { x: 1700, y: 430, width: 14,  height: 22,  color: "#4ecdc4", parallax: 0.3, type: "crystal" },
      { x: 2400, y: 430, width: 16,  height: 20,  color: "#a78bfa", parallax: 0.3, type: "crystal" },
      { x: 2750, y: 430, width: 12,  height: 18,  color: "#4ecdc4", parallax: 0.3, type: "crystal" },
    ],
    portal: null,
    boss: {
      x: 2350, y: 306, width: 120, height: 144,
      speed: 0.6, direction: 1, minX: 2120, maxX: 2880,
      hp: 6, maxHp: 6, color: "#6b21a8",
      invincibleTimer: 0, alive: true,
      velY: 0, onGround: false,
      jumpTimer: 150, shootTimer: 120,
    },
  },

  // ---- SECRET LEVEL 3 (Poodle Cave) ----
  {
    backgroundKey: "secretCave",
    platforms: [
      { x: 0, y: 450, width: 800, height: 50, color: "#3a2a1a" },
    ],
    enemies: [],
    decorations: [],
    portal: null,
    boss: null,
  },
];

// =============================================================================
// ACTIVE LEVEL STATE
// =============================================================================

let currentLevel = 0;
let activePlatforms = [];
let activeEnemies = [];
let activeDecorations = [];
let activePortal = null;
let activeBoss = null;

// Projectile & death effect state
let projectiles = [];          // Active projectiles in flight
let bossProjectiles = [];      // Boss blaster projectiles
let deathEffects = [];         // Enemy death particle animations
let shootCooldown = 0;         // Cooldown timer between shots

// Transition state
let transitionTimer = 0;      // Counts down during fade transitions
let transitionPhase = "";      // "fadeOut" or "fadeIn"
let nextLevelIndex = -1;       // Level to load during transition

// Victory state
let victoryScreen = false;

// Secret corvette mode
let corvetteMode = false;

// Secret level state
let secretDoor = null;          // { x, y, width, height, hp, maxHp, broken, hpBarTimer }
let hasSword = false;           // Player picked up sword
let isPoodle = false;           // Player transformed into poodle
let poodleMode = false;         // Poodle car unlocked
let secretLevelState = null;    // null or { phase, npc, dialogueTimer, ... }
let secretCaveAnimTimer = 0;    // For animated cave background
let secretCaveAnimFrame = 0;
let beamDamageTimer = 0;        // Cooldown between beam damage ticks

// =============================================================================
// WEB AUDIO API — PROCEDURAL SOUND EFFECTS (zero file size)
// =============================================================================

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

/** Helper: create white noise buffer of given duration */
function createNoise(duration) {
  const len = audioCtx.sampleRate * duration;
  const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < len; i++) d[i] = Math.random() * 2 - 1;
  return buf;
}

// --- Persistent engine rumble for corvette mode ---
let engineNodes = null; // { osc1, osc2, lfo, noise, gainMaster } when active

function startEngine() {
  if (engineNodes) return; // already running
  if (audioCtx.state === "suspended") audioCtx.resume();

  // Layer 1: low sawtooth drone (fundamental engine tone)
  const osc1 = audioCtx.createOscillator();
  const g1 = audioCtx.createGain();
  const lp1 = audioCtx.createBiquadFilter();
  osc1.type = "sawtooth";
  osc1.frequency.value = 55;
  lp1.type = "lowpass"; lp1.frequency.value = 200; lp1.Q.value = 3;
  g1.gain.value = 0.12;
  osc1.connect(lp1).connect(g1);

  // Layer 2: slightly detuned second oscillator for thickness
  const osc2 = audioCtx.createOscillator();
  const g2 = audioCtx.createGain();
  const lp2 = audioCtx.createBiquadFilter();
  osc2.type = "sawtooth";
  osc2.frequency.value = 55.5; // slight detune
  lp2.type = "lowpass"; lp2.frequency.value = 180; lp2.Q.value = 2;
  g2.gain.value = 0.08;
  osc2.connect(lp2).connect(g2);

  // Layer 3: LFO wobble on the pitch for engine chug
  const lfo = audioCtx.createOscillator();
  const lfoG = audioCtx.createGain();
  lfo.type = "sine";
  lfo.frequency.value = 6; // 6Hz chug
  lfoG.gain.value = 4; // subtle pitch wobble
  lfo.connect(lfoG);
  lfoG.connect(osc1.frequency);
  lfoG.connect(osc2.frequency);

  // Layer 4: low rumble noise through a lowpass
  const nBuf = createNoise(2);
  const noise = audioCtx.createBufferSource();
  noise.buffer = nBuf;
  noise.loop = true;
  const nLp = audioCtx.createBiquadFilter();
  nLp.type = "lowpass"; nLp.frequency.value = 150; nLp.Q.value = 1;
  const nG = audioCtx.createGain();
  nG.gain.value = 0.04;
  noise.connect(nLp).connect(nG);

  // Waveshaper for grit
  const ws = audioCtx.createWaveShaper();
  const curve = new Float32Array(256);
  for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = Math.tanh(x * 2); }
  ws.curve = curve;

  // Master gain (for fade in/out)
  const gainMaster = audioCtx.createGain();
  gainMaster.gain.value = 0;
  gainMaster.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.15);

  g1.connect(ws);
  g2.connect(ws);
  nG.connect(gainMaster);
  ws.connect(gainMaster);
  gainMaster.connect(audioCtx.destination);

  osc1.start(); osc2.start(); lfo.start(); noise.start();

  engineNodes = { osc1, osc2, lfo, noise, gainMaster };
}

function stopEngine() {
  if (!engineNodes) return;
  const t = audioCtx.currentTime;
  engineNodes.gainMaster.gain.setValueAtTime(engineNodes.gainMaster.gain.value, t);
  engineNodes.gainMaster.gain.linearRampToValueAtTime(0, t + 0.2);
  const nodes = engineNodes;
  engineNodes = null;
  setTimeout(() => {
    try { nodes.osc1.stop(); } catch(e) {}
    try { nodes.osc2.stop(); } catch(e) {}
    try { nodes.lfo.stop(); } catch(e) {}
    try { nodes.noise.stop(); } catch(e) {}
    nodes.gainMaster.disconnect();
  }, 250);
}

// --- Persistent lightsaber hum for beam weapon ---
let beamSoundNodes = null;

function startBeamSound() {
  if (beamSoundNodes) return;
  if (audioCtx.state === "suspended") audioCtx.resume();
  const t = audioCtx.currentTime;

  if (isPoodle) {
    // === POODLE FART BEAM SOUND ===

    // Initial blast — short low burst
    const blast = audioCtx.createOscillator();
    const blastG = audioCtx.createGain();
    const blastLp = audioCtx.createBiquadFilter();
    blast.type = "sawtooth";
    blast.frequency.setValueAtTime(90, t);
    blast.frequency.exponentialRampToValueAtTime(55, t + 0.15);
    blastLp.type = "lowpass"; blastLp.frequency.value = 250; blastLp.Q.value = 3;
    blastG.gain.setValueAtTime(0.25, t);
    blastG.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    blast.connect(blastLp).connect(blastG).connect(audioCtx.destination);
    blast.start(t); blast.stop(t + 0.25);

    // Initial splutter noise
    const splut = audioCtx.createBufferSource();
    splut.buffer = createNoise(0.2);
    const splutLp = audioCtx.createBiquadFilter();
    splutLp.type = "lowpass"; splutLp.frequency.value = 400; splutLp.Q.value = 2;
    const splutG = audioCtx.createGain();
    splutG.gain.setValueAtTime(0.15, t);
    splutG.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
    splut.connect(splutLp).connect(splutG).connect(audioCtx.destination);
    splut.start(t);

    // === Persistent rumble layers ===

    // Layer 1: Deep rumble — triangle at ~65Hz with wobble
    const hum1 = audioCtx.createOscillator();
    const hum1G = audioCtx.createGain();
    const hum1Lp = audioCtx.createBiquadFilter();
    hum1.type = "triangle";
    hum1.frequency.value = 65;
    hum1Lp.type = "lowpass"; hum1Lp.frequency.value = 200; hum1Lp.Q.value = 5;
    hum1G.gain.value = 0.1;
    hum1.connect(hum1Lp).connect(hum1G);

    // Layer 2: Sub bass flutter — square at ~45Hz for that flappy vibration
    const hum2 = audioCtx.createOscillator();
    const hum2G = audioCtx.createGain();
    hum2.type = "square";
    hum2.frequency.value = 45;
    hum2G.gain.value = 0.06;
    const hum2Lp = audioCtx.createBiquadFilter();
    hum2Lp.type = "lowpass"; hum2Lp.frequency.value = 150; hum2Lp.Q.value = 3;
    hum2.connect(hum2Lp).connect(hum2G);

    // Layer 3: Mid-range buzz for the "brrrap" texture
    const buzz = audioCtx.createOscillator();
    const buzzG = audioCtx.createGain();
    const buzzLp = audioCtx.createBiquadFilter();
    buzz.type = "sawtooth";
    buzz.frequency.value = 110;
    buzzLp.type = "lowpass"; buzzLp.frequency.value = 350; buzzLp.Q.value = 4;
    buzzG.gain.value = 0.04;
    buzz.connect(buzzLp).connect(buzzG);

    // Layer 4: Irregular flutter LFO — makes it sound organic and sputtery
    const lfo = audioCtx.createOscillator();
    const lfoG = audioCtx.createGain();
    lfo.type = "sawtooth";
    lfo.frequency.value = 8; // fast flutter
    lfoG.gain.value = 15;    // wide pitch modulation for flappy effect
    lfo.connect(lfoG);
    lfoG.connect(hum1.frequency);
    lfoG.connect(hum2.frequency);
    lfoG.connect(buzz.frequency);

    // Layer 5: Filtered brown noise for airy hiss
    const nBuf = createNoise(2);
    const noise = audioCtx.createBufferSource();
    noise.buffer = nBuf;
    noise.loop = true;
    const nLp = audioCtx.createBiquadFilter();
    nLp.type = "lowpass"; nLp.frequency.value = 500; nLp.Q.value = 1;
    const nG = audioCtx.createGain();
    nG.gain.value = 0.04;
    noise.connect(nLp).connect(nG);

    // Waveshaper for wet, squelchy distortion
    const ws = audioCtx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = Math.tanh(x * 5); }
    ws.curve = curve;

    // Master gain with fade-in
    const gainMaster = audioCtx.createGain();
    gainMaster.gain.setValueAtTime(0, t);
    gainMaster.gain.linearRampToValueAtTime(1, t + 0.05);

    hum1G.connect(ws);
    hum2G.connect(ws);
    buzzG.connect(ws);
    ws.connect(gainMaster);
    nG.connect(gainMaster);
    gainMaster.connect(audioCtx.destination);

    hum1.start(); hum2.start(); buzz.start(); lfo.start(); noise.start();

    beamSoundNodes = { hum1, hum2, buzz, lfo, noise, gainMaster };
    return;
  }

  // === NORMAL LIGHTSABER BEAM SOUND ===

  // === Ignition zap — one-shot on activation ===
  // Fast rising buzz sweep (lightsaber ignite)
  const ign = audioCtx.createOscillator();
  const ignG = audioCtx.createGain();
  const ignLp = audioCtx.createBiquadFilter();
  ign.type = "sawtooth";
  ign.frequency.setValueAtTime(80, t);
  ign.frequency.exponentialRampToValueAtTime(220, t + 0.08);
  ign.frequency.exponentialRampToValueAtTime(120, t + 0.2);
  ignLp.type = "lowpass";
  ignLp.frequency.setValueAtTime(400, t);
  ignLp.frequency.exponentialRampToValueAtTime(3000, t + 0.06);
  ignLp.frequency.exponentialRampToValueAtTime(800, t + 0.2);
  ignLp.Q.value = 5;
  ignG.gain.setValueAtTime(0.18, t);
  ignG.gain.setValueAtTime(0.18, t + 0.05);
  ignG.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
  ign.connect(ignLp).connect(ignG).connect(audioCtx.destination);
  ign.start(t); ign.stop(t + 0.25);

  // Ignition high crackle
  const ignNoise = audioCtx.createBufferSource();
  ignNoise.buffer = createNoise(0.15);
  const ignBp = audioCtx.createBiquadFilter();
  ignBp.type = "bandpass"; ignBp.frequency.value = 5000; ignBp.Q.value = 3;
  const ignNg = audioCtx.createGain();
  ignNg.gain.setValueAtTime(0.08, t);
  ignNg.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
  ignNoise.connect(ignBp).connect(ignNg).connect(audioCtx.destination);
  ignNoise.start(t);

  // === Persistent hum layers (loop until stopped) ===

  // Layer 1: Core hum — sawtooth at ~120Hz (A2-ish) through resonant lowpass
  const hum1 = audioCtx.createOscillator();
  const hum1G = audioCtx.createGain();
  const hum1Lp = audioCtx.createBiquadFilter();
  hum1.type = "sawtooth";
  hum1.frequency.value = 120;
  hum1Lp.type = "lowpass"; hum1Lp.frequency.value = 500; hum1Lp.Q.value = 4;
  hum1G.gain.value = 0.07;
  hum1.connect(hum1Lp).connect(hum1G);

  // Layer 2: Detuned second oscillator for thickness
  const hum2 = audioCtx.createOscillator();
  const hum2G = audioCtx.createGain();
  hum2.type = "sawtooth";
  hum2.frequency.value = 121.5; // slight detune for beating
  hum2G.gain.value = 0.05;
  hum2.connect(hum2G);

  // Layer 3: Higher harmonic buzz — square at 240Hz for that electric edge
  const buzz = audioCtx.createOscillator();
  const buzzG = audioCtx.createGain();
  const buzzBp = audioCtx.createBiquadFilter();
  buzz.type = "square";
  buzz.frequency.value = 240;
  buzzBp.type = "bandpass"; buzzBp.frequency.value = 600; buzzBp.Q.value = 3;
  buzzG.gain.value = 0.03;
  buzz.connect(buzzBp).connect(buzzG);

  // Layer 4: LFO modulating pitch for alive, wavering feel
  const lfo = audioCtx.createOscillator();
  const lfoG = audioCtx.createGain();
  lfo.type = "sine";
  lfo.frequency.value = 5; // 5Hz wobble
  lfoG.gain.value = 3;     // subtle pitch modulation
  lfo.connect(lfoG);
  lfoG.connect(hum1.frequency);
  lfoG.connect(hum2.frequency);
  lfoG.connect(buzz.frequency);

  // Layer 5: Filtered noise hiss for plasma texture
  const nBuf = createNoise(2);
  const noise = audioCtx.createBufferSource();
  noise.buffer = nBuf;
  noise.loop = true;
  const nBp = audioCtx.createBiquadFilter();
  nBp.type = "bandpass"; nBp.frequency.value = 2000; nBp.Q.value = 2;
  const nG = audioCtx.createGain();
  nG.gain.value = 0.015;
  noise.connect(nBp).connect(nG);

  // Waveshaper for grit/distortion
  const ws = audioCtx.createWaveShaper();
  const curve = new Float32Array(256);
  for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = Math.tanh(x * 3); }
  ws.curve = curve;

  // Master gain with fade-in
  const gainMaster = audioCtx.createGain();
  gainMaster.gain.setValueAtTime(0, t);
  gainMaster.gain.linearRampToValueAtTime(1, t + 0.1);

  hum1G.connect(ws);
  hum2G.connect(ws);
  buzzG.connect(ws);
  ws.connect(gainMaster);
  nG.connect(gainMaster);
  gainMaster.connect(audioCtx.destination);

  hum1.start(); hum2.start(); buzz.start(); lfo.start(); noise.start();

  beamSoundNodes = { hum1, hum2, buzz, lfo, noise, gainMaster };
}

function stopBeamSound() {
  if (!beamSoundNodes) return;
  const t = audioCtx.currentTime;
  beamSoundNodes.gainMaster.gain.setValueAtTime(beamSoundNodes.gainMaster.gain.value, t);
  beamSoundNodes.gainMaster.gain.linearRampToValueAtTime(0, t + 0.15);
  const nodes = beamSoundNodes;
  beamSoundNodes = null;
  setTimeout(() => {
    try { nodes.hum1.stop(); } catch(e) {}
    try { nodes.hum2.stop(); } catch(e) {}
    try { nodes.buzz.stop(); } catch(e) {}
    try { nodes.lfo.stop(); } catch(e) {}
    try { nodes.noise.stop(); } catch(e) {}
    nodes.gainMaster.disconnect();
  }, 200);
}

function playSound(type) {
  if (audioCtx.state === "suspended") audioCtx.resume();
  const t = audioCtx.currentTime;

  if (type === "jump") {
    // Layered jump: bright sine sweep + airy noise whoosh + sub-bass punch
    // Layer 1: main tone sweep with vibrato
    const osc = audioCtx.createOscillator();
    const oscGain = audioCtx.createGain();
    const lfo = audioCtx.createOscillator();
    const lfoGain = audioCtx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(280, t);
    osc.frequency.exponentialRampToValueAtTime(900, t + 0.12);
    osc.frequency.exponentialRampToValueAtTime(700, t + 0.18);
    lfo.type = "sine";
    lfo.frequency.value = 30;
    lfoGain.gain.value = 40;
    lfo.connect(lfoGain).connect(osc.frequency);
    oscGain.gain.setValueAtTime(0.13, t);
    oscGain.gain.setValueAtTime(0.13, t + 0.06);
    oscGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc.connect(oscGain).connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.2);
    lfo.start(t); lfo.stop(t + 0.2);

    // Layer 2: breathy noise whoosh through bandpass
    const noise = audioCtx.createBufferSource();
    noise.buffer = createNoise(0.15);
    const bp = audioCtx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(2000, t);
    bp.frequency.exponentialRampToValueAtTime(5000, t + 0.1);
    bp.Q.value = 2;
    const nGain = audioCtx.createGain();
    nGain.gain.setValueAtTime(0.04, t);
    nGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    noise.connect(bp).connect(nGain).connect(audioCtx.destination);
    noise.start(t);

    // Layer 3: sub-bass thump for weight
    const sub = audioCtx.createOscillator();
    const subGain = audioCtx.createGain();
    sub.type = "sine";
    sub.frequency.setValueAtTime(120, t);
    sub.frequency.exponentialRampToValueAtTime(60, t + 0.08);
    subGain.gain.setValueAtTime(0.12, t);
    subGain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    sub.connect(subGain).connect(audioCtx.destination);
    sub.start(t); sub.stop(t + 0.1);
  }

  else if (type === "car_jump") {
    // Engine rev + tire screech: revving sawtooth sweep + filtered noise screech + sub thump

    // Layer 1: engine rev — sawtooth through lowpass, rising pitch
    const rev = audioCtx.createOscillator();
    const revLp = audioCtx.createBiquadFilter();
    const revG = audioCtx.createGain();
    const revWs = audioCtx.createWaveShaper();
    const revCurve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; revCurve[i] = Math.tanh(x * 3); }
    revWs.curve = revCurve;
    rev.type = "sawtooth";
    rev.frequency.setValueAtTime(60, t);
    rev.frequency.exponentialRampToValueAtTime(180, t + 0.15);
    rev.frequency.exponentialRampToValueAtTime(120, t + 0.35);
    revLp.type = "lowpass";
    revLp.frequency.setValueAtTime(300, t);
    revLp.frequency.exponentialRampToValueAtTime(800, t + 0.12);
    revLp.frequency.exponentialRampToValueAtTime(400, t + 0.35);
    revLp.Q.value = 4;
    revG.gain.setValueAtTime(0.14, t);
    revG.gain.setValueAtTime(0.14, t + 0.12);
    revG.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
    rev.connect(revWs).connect(revLp).connect(revG).connect(audioCtx.destination);
    rev.start(t); rev.stop(t + 0.35);

    // Layer 2: second detuned saw for engine thickness
    const rev2 = audioCtx.createOscillator();
    const rev2G = audioCtx.createGain();
    rev2.type = "sawtooth";
    rev2.frequency.setValueAtTime(61, t);
    rev2.frequency.exponentialRampToValueAtTime(182, t + 0.15);
    rev2.frequency.exponentialRampToValueAtTime(121, t + 0.35);
    rev2G.gain.setValueAtTime(0.06, t);
    rev2G.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
    rev2.connect(revWs).connect(rev2G).connect(audioCtx.destination);
    rev2.start(t); rev2.stop(t + 0.35);

    // Layer 3: tire screech — bandpass noise rising in pitch
    const screech = audioCtx.createBufferSource();
    screech.buffer = createNoise(0.25);
    const sBp = audioCtx.createBiquadFilter();
    sBp.type = "bandpass";
    sBp.frequency.setValueAtTime(2000, t);
    sBp.frequency.exponentialRampToValueAtTime(5000, t + 0.08);
    sBp.frequency.exponentialRampToValueAtTime(3000, t + 0.2);
    sBp.Q.value = 8;
    const sG = audioCtx.createGain();
    sG.gain.setValueAtTime(0.06, t);
    sG.gain.setValueAtTime(0.06, t + 0.05);
    sG.gain.exponentialRampToValueAtTime(0.001, t + 0.22);
    screech.connect(sBp).connect(sG).connect(audioCtx.destination);
    screech.start(t);

    // Layer 4: sub-bass launch thump
    const sub = audioCtx.createOscillator();
    const subG = audioCtx.createGain();
    sub.type = "sine";
    sub.frequency.setValueAtTime(80, t);
    sub.frequency.exponentialRampToValueAtTime(35, t + 0.12);
    subG.gain.setValueAtTime(0.16, t);
    subG.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    sub.connect(subG).connect(audioCtx.destination);
    sub.start(t); sub.stop(t + 0.15);
  }

  else if (type === "shoot") {
    // Punchy laser: layered square + saw sweep through resonant filter + click transient
    // Layer 1: resonant square sweep
    const osc1 = audioCtx.createOscillator();
    const filt = audioCtx.createBiquadFilter();
    const g1 = audioCtx.createGain();
    osc1.type = "square";
    osc1.frequency.setValueAtTime(1200, t);
    osc1.frequency.exponentialRampToValueAtTime(180, t + 0.1);
    filt.type = "lowpass";
    filt.frequency.setValueAtTime(4000, t);
    filt.frequency.exponentialRampToValueAtTime(400, t + 0.1);
    filt.Q.value = 8;
    g1.gain.setValueAtTime(0.07, t);
    g1.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    osc1.connect(filt).connect(g1).connect(audioCtx.destination);
    osc1.start(t); osc1.stop(t + 0.12);

    // Layer 2: bright saw harmonic
    const osc2 = audioCtx.createOscillator();
    const g2 = audioCtx.createGain();
    osc2.type = "sawtooth";
    osc2.frequency.setValueAtTime(900, t);
    osc2.frequency.exponentialRampToValueAtTime(300, t + 0.06);
    g2.gain.setValueAtTime(0.04, t);
    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    osc2.connect(g2).connect(audioCtx.destination);
    osc2.start(t); osc2.stop(t + 0.08);

    // Layer 3: sharp click transient
    const click = audioCtx.createOscillator();
    const cg = audioCtx.createGain();
    click.type = "square";
    click.frequency.value = 3000;
    cg.gain.setValueAtTime(0.08, t);
    cg.gain.exponentialRampToValueAtTime(0.001, t + 0.01);
    click.connect(cg).connect(audioCtx.destination);
    click.start(t); click.stop(t + 0.015);
  }

  else if (type === "shoot_triple") {
    // Beefier triple-shot: detuned dual-saw + filtered noise burst + sub punch
    // Layer 1: dual detuned sawtooths
    for (const detune of [-15, 15]) {
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      const f = audioCtx.createBiquadFilter();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(800, t);
      osc.frequency.exponentialRampToValueAtTime(120, t + 0.14);
      osc.detune.value = detune;
      f.type = "lowpass";
      f.frequency.setValueAtTime(5000, t);
      f.frequency.exponentialRampToValueAtTime(300, t + 0.14);
      f.Q.value = 5;
      g.gain.setValueAtTime(0.06, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.connect(f).connect(g).connect(audioCtx.destination);
      osc.start(t); osc.stop(t + 0.15);
    }

    // Layer 2: noise punch
    const ns = audioCtx.createBufferSource();
    ns.buffer = createNoise(0.06);
    const bp = audioCtx.createBiquadFilter();
    bp.type = "bandpass"; bp.frequency.value = 3000; bp.Q.value = 1;
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.06, t);
    ng.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
    ns.connect(bp).connect(ng).connect(audioCtx.destination);
    ns.start(t);

    // Layer 3: sub-bass thump
    const sub = audioCtx.createOscillator();
    const sg = audioCtx.createGain();
    sub.type = "sine";
    sub.frequency.setValueAtTime(100, t);
    sub.frequency.exponentialRampToValueAtTime(40, t + 0.1);
    sg.gain.setValueAtTime(0.1, t);
    sg.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    sub.connect(sg).connect(audioCtx.destination);
    sub.start(t); sub.stop(t + 0.1);
  }

  else if (type === "enemy_death") {
    // Randomize pitch slightly each time for variety
    const pitch = 0.9 + Math.random() * 0.3;
    const variant = Math.floor(Math.random() * 3);

    if (variant === 0) {
      // "Splat-pop": descending FM tone + noise crackle + pop
      const mod = audioCtx.createOscillator();
      const modG = audioCtx.createGain();
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      mod.type = "square";
      mod.frequency.setValueAtTime(200 * pitch, t);
      mod.frequency.exponentialRampToValueAtTime(30, t + 0.25);
      modG.gain.setValueAtTime(300, t);
      modG.gain.linearRampToValueAtTime(50, t + 0.25);
      mod.connect(modG).connect(osc.frequency);
      osc.type = "sine";
      osc.frequency.setValueAtTime(500 * pitch, t);
      osc.frequency.exponentialRampToValueAtTime(60, t + 0.3);
      g.gain.setValueAtTime(0.15, t);
      g.gain.setValueAtTime(0.12, t + 0.05);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.connect(g).connect(audioCtx.destination);
      osc.start(t); osc.stop(t + 0.3);
      mod.start(t); mod.stop(t + 0.3);
      // Crackle noise
      const ns = audioCtx.createBufferSource();
      ns.buffer = createNoise(0.12);
      const hp = audioCtx.createBiquadFilter();
      hp.type = "highpass"; hp.frequency.value = 4000;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.06, t);
      ng.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
      ns.connect(hp).connect(ng).connect(audioCtx.destination);
      ns.start(t);
    } else if (variant === 1) {
      // "Bip-bwoop": two-tone with filter sweep
      const o1 = audioCtx.createOscillator();
      const f1 = audioCtx.createBiquadFilter();
      const g1 = audioCtx.createGain();
      o1.type = "square";
      o1.frequency.setValueAtTime(700 * pitch, t);
      o1.frequency.exponentialRampToValueAtTime(350 * pitch, t + 0.06);
      f1.type = "lowpass"; f1.frequency.value = 3000; f1.Q.value = 4;
      g1.gain.setValueAtTime(0.1, t);
      g1.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
      o1.connect(f1).connect(g1).connect(audioCtx.destination);
      o1.start(t); o1.stop(t + 0.07);
      // Second tone: FM wobble descent
      const mod = audioCtx.createOscillator();
      const modG = audioCtx.createGain();
      const o2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      mod.type = "sine"; mod.frequency.value = 12;
      modG.gain.value = 80;
      mod.connect(modG).connect(o2.frequency);
      o2.type = "sine";
      o2.frequency.setValueAtTime(480 * pitch, t + 0.09);
      o2.frequency.exponentialRampToValueAtTime(55, t + 0.38);
      g2.gain.setValueAtTime(0.001, t);
      g2.gain.setValueAtTime(0.14, t + 0.09);
      g2.gain.exponentialRampToValueAtTime(0.001, t + 0.38);
      o2.connect(g2).connect(audioCtx.destination);
      o2.start(t + 0.09); o2.stop(t + 0.38);
      mod.start(t + 0.09); mod.stop(t + 0.38);
    } else {
      // "Crunch-thud": filtered noise burst into distorted sub drop
      const ns = audioCtx.createBufferSource();
      ns.buffer = createNoise(0.2);
      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.setValueAtTime(5000, t);
      bp.frequency.exponentialRampToValueAtTime(500, t + 0.15);
      bp.Q.value = 3;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.12, t);
      ng.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
      ns.connect(bp).connect(ng).connect(audioCtx.destination);
      ns.start(t);
      // Sub thud with waveshaper for grit
      const osc = audioCtx.createOscillator();
      const ws = audioCtx.createWaveShaper();
      const curve = new Float32Array(256);
      for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = Math.tanh(x * 3); }
      ws.curve = curve;
      const g = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(110 * pitch, t + 0.06);
      osc.frequency.exponentialRampToValueAtTime(35, t + 0.35);
      g.gain.setValueAtTime(0.001, t);
      g.gain.setValueAtTime(0.18, t + 0.06);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
      osc.connect(ws).connect(g).connect(audioCtx.destination);
      osc.start(t + 0.06); osc.stop(t + 0.35);
    }
  }

  else if (type === "boss_death") {
    // Epic 4-layer: rising alarm → siren sweep → huge filtered explosion → sub rumble

    // Layer 1: rising alarm (two detuned saws through resonant filter)
    for (const det of [-10, 10]) {
      const osc = audioCtx.createOscillator();
      const f = audioCtx.createBiquadFilter();
      const g = audioCtx.createGain();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(80, t);
      osc.frequency.exponentialRampToValueAtTime(1200, t + 0.6);
      osc.detune.value = det;
      f.type = "lowpass";
      f.frequency.setValueAtTime(300, t);
      f.frequency.exponentialRampToValueAtTime(6000, t + 0.5);
      f.Q.value = 6;
      g.gain.setValueAtTime(0.1, t);
      g.gain.linearRampToValueAtTime(0.18, t + 0.45);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
      osc.connect(f).connect(g).connect(audioCtx.destination);
      osc.start(t); osc.stop(t + 0.6);
    }

    // Layer 2: siren sweep at the peak
    const siren = audioCtx.createOscillator();
    const sLfo = audioCtx.createOscillator();
    const sLfoG = audioCtx.createGain();
    const sg = audioCtx.createGain();
    siren.type = "square";
    siren.frequency.setValueAtTime(600, t + 0.4);
    siren.frequency.linearRampToValueAtTime(1500, t + 0.55);
    siren.frequency.linearRampToValueAtTime(400, t + 0.7);
    sLfo.type = "sine"; sLfo.frequency.value = 20;
    sLfoG.gain.value = 100;
    sLfo.connect(sLfoG).connect(siren.frequency);
    sg.gain.setValueAtTime(0.001, t);
    sg.gain.setValueAtTime(0.08, t + 0.4);
    sg.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
    siren.connect(sg).connect(audioCtx.destination);
    siren.start(t + 0.4); siren.stop(t + 0.7);
    sLfo.start(t + 0.4); sLfo.stop(t + 0.7);

    // Layer 3: massive filtered explosion noise
    const ns = audioCtx.createBufferSource();
    ns.buffer = createNoise(1.2);
    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(10000, t + 0.55);
    lp.frequency.exponentialRampToValueAtTime(200, t + 1.6);
    lp.Q.value = 1;
    const ws = audioCtx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = Math.tanh(x * 2.5); }
    ws.curve = curve;
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.001, t);
    ng.gain.setValueAtTime(0.22, t + 0.55);
    ng.gain.setValueAtTime(0.18, t + 0.8);
    ng.gain.exponentialRampToValueAtTime(0.001, t + 1.7);
    ns.connect(ws).connect(lp).connect(ng).connect(audioCtx.destination);
    ns.start(t + 0.5);

    // Layer 4: deep sub rumble with slow wobble
    const sub = audioCtx.createOscillator();
    const subLfo = audioCtx.createOscillator();
    const subLfoG = audioCtx.createGain();
    const subG = audioCtx.createGain();
    sub.type = "sine";
    sub.frequency.setValueAtTime(55, t + 0.8);
    sub.frequency.exponentialRampToValueAtTime(25, t + 2.0);
    subLfo.type = "sine"; subLfo.frequency.value = 4;
    subLfoG.gain.value = 10;
    subLfo.connect(subLfoG).connect(sub.frequency);
    subG.gain.setValueAtTime(0.001, t);
    subG.gain.setValueAtTime(0.2, t + 0.8);
    subG.gain.exponentialRampToValueAtTime(0.001, t + 2.0);
    sub.connect(subG).connect(audioCtx.destination);
    sub.start(t + 0.8); sub.stop(t + 2.0);
    subLfo.start(t + 0.8); subLfo.stop(t + 2.0);
  }

  else if (type === "player_hit") {
    // Crunchy impact: distorted low thud + noise crunch + high ring
    // Layer 1: distorted low thud
    const osc = audioCtx.createOscillator();
    const ws = audioCtx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) { const x = (i / 128) - 1; curve[i] = Math.tanh(x * 4); }
    ws.curve = curve;
    const g = audioCtx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
    g.gain.setValueAtTime(0.18, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
    osc.connect(ws).connect(g).connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.18);

    // Layer 2: noise crunch
    const ns = audioCtx.createBufferSource();
    ns.buffer = createNoise(0.08);
    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass"; lp.frequency.value = 2000; lp.Q.value = 2;
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.08, t);
    ng.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    ns.connect(lp).connect(ng).connect(audioCtx.destination);
    ns.start(t);

    // Layer 3: brief high ring to cut through
    const ring = audioCtx.createOscillator();
    const rg = audioCtx.createGain();
    ring.type = "sine";
    ring.frequency.value = 2200;
    rg.gain.setValueAtTime(0.04, t);
    rg.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
    ring.connect(rg).connect(audioCtx.destination);
    ring.start(t); ring.stop(t + 0.06);
  }

  else if (type === "boss_hit") {
    // Heavy metallic clang: FM bell tone + resonant filter ping + impact noise
    // Layer 1: FM bell (carrier + modulator for inharmonic metallic tone)
    const mod = audioCtx.createOscillator();
    const modG = audioCtx.createGain();
    const car = audioCtx.createOscillator();
    const cg = audioCtx.createGain();
    mod.type = "sine";
    mod.frequency.value = 1870;
    modG.gain.setValueAtTime(600, t);
    modG.gain.exponentialRampToValueAtTime(50, t + 0.25);
    mod.connect(modG).connect(car.frequency);
    car.type = "sine";
    car.frequency.value = 950;
    cg.gain.setValueAtTime(0.12, t);
    cg.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    car.connect(cg).connect(audioCtx.destination);
    car.start(t); car.stop(t + 0.3);
    mod.start(t); mod.stop(t + 0.3);

    // Layer 2: resonant ping through bandpass
    const ping = audioCtx.createOscillator();
    const bp = audioCtx.createBiquadFilter();
    const pg = audioCtx.createGain();
    ping.type = "triangle";
    ping.frequency.setValueAtTime(3200, t);
    ping.frequency.exponentialRampToValueAtTime(1800, t + 0.12);
    bp.type = "bandpass"; bp.frequency.value = 2500; bp.Q.value = 10;
    pg.gain.setValueAtTime(0.06, t);
    pg.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    ping.connect(bp).connect(pg).connect(audioCtx.destination);
    ping.start(t); ping.stop(t + 0.15);

    // Layer 3: short noise impact for weight
    const ns = audioCtx.createBufferSource();
    ns.buffer = createNoise(0.04);
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.07, t);
    ng.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
    ns.connect(ng).connect(audioCtx.destination);
    ns.start(t);
  }

  else if (type === "enemy_hit") {
    // Short punchy impact: noise burst + mid-frequency thud (~0.1s)
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = "sine";
    osc.frequency.setValueAtTime(300, t);
    osc.frequency.exponentialRampToValueAtTime(100, t + 0.08);
    g.gain.setValueAtTime(0.12, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    osc.connect(g).connect(audioCtx.destination);
    osc.start(t); osc.stop(t + 0.1);

    const ns2 = audioCtx.createBufferSource();
    ns2.buffer = createNoise(0.06);
    const bp2 = audioCtx.createBiquadFilter();
    bp2.type = "bandpass"; bp2.frequency.value = 2000; bp2.Q.value = 2;
    const ng2 = audioCtx.createGain();
    ng2.gain.setValueAtTime(0.06, t);
    ng2.gain.exponentialRampToValueAtTime(0.001, t + 0.06);
    ns2.connect(bp2).connect(ng2).connect(audioCtx.destination);
    ns2.start(t);
  }

  else if (type === "sword_appear") {
    // Epic sword reveal: celestial choir chord + shimmering harmonics + deep power swell
    // ~4 seconds of dramatic, building music

    // Layer 1: Choir-like pad — stacked fifths with slow attack (C4-G4-C5-E5)
    const choirNotes = [261.6, 392.0, 523.3, 659.3];
    for (let i = 0; i < choirNotes.length; i++) {
      const o = audioCtx.createOscillator();
      const g1 = audioCtx.createGain();
      const lp = audioCtx.createBiquadFilter();
      o.type = "sawtooth";
      o.frequency.value = choirNotes[i];
      lp.type = "lowpass";
      lp.frequency.setValueAtTime(600, t);
      lp.frequency.linearRampToValueAtTime(1800, t + 1.5);
      lp.frequency.linearRampToValueAtTime(1200, t + 4.0);
      lp.Q.value = 1;
      g1.gain.setValueAtTime(0, t);
      g1.gain.linearRampToValueAtTime(0.04, t + 0.8);
      g1.gain.setValueAtTime(0.04, t + 2.5);
      g1.gain.linearRampToValueAtTime(0, t + 4.0);
      o.connect(lp).connect(g1).connect(audioCtx.destination);
      o.start(t); o.stop(t + 4.1);

      // Slight detune for width
      const o2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      o2.type = "sawtooth";
      o2.frequency.value = choirNotes[i] * 1.003;
      g2.gain.setValueAtTime(0, t);
      g2.gain.linearRampToValueAtTime(0.03, t + 0.8);
      g2.gain.setValueAtTime(0.03, t + 2.5);
      g2.gain.linearRampToValueAtTime(0, t + 4.0);
      o2.connect(lp).connect(g2).connect(audioCtx.destination);
      o2.start(t); o2.stop(t + 4.1);
    }

    // Layer 2: Rising shimmer — metallic harmonics sweep up
    const shimmer = audioCtx.createOscillator();
    const shimGain = audioCtx.createGain();
    const shimBp = audioCtx.createBiquadFilter();
    shimmer.type = "square";
    shimmer.frequency.setValueAtTime(2000, t);
    shimmer.frequency.exponentialRampToValueAtTime(6000, t + 2.0);
    shimmer.frequency.exponentialRampToValueAtTime(4000, t + 3.5);
    shimBp.type = "bandpass";
    shimBp.frequency.setValueAtTime(3000, t);
    shimBp.frequency.exponentialRampToValueAtTime(8000, t + 2.0);
    shimBp.Q.value = 8;
    shimGain.gain.setValueAtTime(0, t + 0.3);
    shimGain.gain.linearRampToValueAtTime(0.015, t + 1.0);
    shimGain.gain.linearRampToValueAtTime(0.02, t + 2.0);
    shimGain.gain.linearRampToValueAtTime(0, t + 3.5);
    shimmer.connect(shimBp).connect(shimGain).connect(audioCtx.destination);
    shimmer.start(t + 0.3); shimmer.stop(t + 3.6);

    // Layer 3: Deep power bass — sub-bass swell with octave
    const bass = audioCtx.createOscillator();
    const bassG = audioCtx.createGain();
    bass.type = "sine";
    bass.frequency.setValueAtTime(65.4, t); // C2
    bass.frequency.setValueAtTime(65.4, t + 1.5);
    bass.frequency.linearRampToValueAtTime(130.8, t + 2.5); // octave up
    bassG.gain.setValueAtTime(0, t);
    bassG.gain.linearRampToValueAtTime(0.15, t + 1.0);
    bassG.gain.setValueAtTime(0.15, t + 2.5);
    bassG.gain.linearRampToValueAtTime(0, t + 4.0);
    bass.connect(bassG).connect(audioCtx.destination);
    bass.start(t); bass.stop(t + 4.1);

    // Layer 4: Impact hit at the peak — dramatic reveal moment
    const impact = audioCtx.createOscillator();
    const impG = audioCtx.createGain();
    impact.type = "sine";
    impact.frequency.setValueAtTime(80, t + 2.0);
    impact.frequency.exponentialRampToValueAtTime(40, t + 2.4);
    impG.gain.setValueAtTime(0, t + 1.99);
    impG.gain.linearRampToValueAtTime(0.2, t + 2.01);
    impG.gain.exponentialRampToValueAtTime(0.001, t + 2.5);
    impact.connect(impG).connect(audioCtx.destination);
    impact.start(t + 2.0); impact.stop(t + 2.5);

    // Impact noise burst
    const impNoise = audioCtx.createBufferSource();
    impNoise.buffer = createNoise(0.3);
    const impBp = audioCtx.createBiquadFilter();
    impBp.type = "bandpass"; impBp.frequency.value = 4000; impBp.Q.value = 1;
    const impNg = audioCtx.createGain();
    impNg.gain.setValueAtTime(0, t + 1.99);
    impNg.gain.linearRampToValueAtTime(0.06, t + 2.02);
    impNg.gain.exponentialRampToValueAtTime(0.001, t + 2.3);
    impNoise.connect(impBp).connect(impNg).connect(audioCtx.destination);
    impNoise.start(t + 2.0);

    // Layer 5: Ethereal bell tones — descending arpeggio at the end
    const bellNotes = [1318.5, 1047, 784, 659.3]; // E6, C6, G5, E5
    for (let i = 0; i < bellNotes.length; i++) {
      const bell = audioCtx.createOscillator();
      const bellG = audioCtx.createGain();
      bell.type = "sine";
      bell.frequency.value = bellNotes[i];
      const bellT = t + 2.2 + i * 0.2;
      bellG.gain.setValueAtTime(0.06, bellT);
      bellG.gain.exponentialRampToValueAtTime(0.001, bellT + 0.8);
      bell.connect(bellG).connect(audioCtx.destination);
      bell.start(bellT); bell.stop(bellT + 0.9);

      // Harmonic overtone
      const bell2 = audioCtx.createOscillator();
      const bellG2 = audioCtx.createGain();
      bell2.type = "sine";
      bell2.frequency.value = bellNotes[i] * 2.0;
      bellG2.gain.setValueAtTime(0.02, bellT);
      bellG2.gain.exponentialRampToValueAtTime(0.001, bellT + 0.5);
      bell2.connect(bellG2).connect(audioCtx.destination);
      bell2.start(bellT); bell2.stop(bellT + 0.6);
    }
  }
}

/** Deep-copy an object (works for plain data) */
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

/** Load a level by index, resetting all active state */
function loadLevel(index) {
  currentLevel = index;
  const level = levels[index];

  activePlatforms = level.platforms;     // Platforms don't mutate
  activeDecorations = level.decorations; // Decorations don't mutate
  activeEnemies = deepCopy(level.enemies);
  activePortal = level.portal ? deepCopy(level.portal) : null;
  activeBoss = level.boss ? deepCopy(level.boss) : null;

  projectiles = [];
  bossProjectiles = [];
  deathEffects = [];
  shootCooldown = 0;

  player.reset();
  camera.x = 0;
  camera.y = 0;
  victoryScreen = false;

  // Secret door on Level 1 — placed on a random floating platform
  if (index === 0) {
    const floatingIndices = [1, 2, 3, 4, 6, 7, 8, 9];
    const pick = floatingIndices[Math.floor(Math.random() * floatingIndices.length)];
    const plat = activePlatforms[pick];
    secretDoor = {
      x: plat.x + plat.width / 2 - 24,
      y: plat.y - 64,
      width: 48, height: 64,
      hp: 5, maxHp: 5,
      broken: false,
      hpBarTimer: 0,
    };
  } else {
    secretDoor = null;
  }

  // Secret level initialization
  if (index === 2) {
    secretLevelState = {
      phase: "walk",
      npc: { x: 650, y: 450 - 80, width: 60, height: 80, animFrame: 0, animTimer: 0, facing: -1 },
      dialogueTimer: 0,
      dialogueChars: 0,
      fullDialogue: "It's dangerous to go alone. Here, take this.",
      swordY: -50,
      swordTargetY: 220,
      swordAnimFrame: 0,
      swordAnimTimer: 0,
      choiceMade: null,
      exitTimer: 0,
    };
  } else {
    secretLevelState = null;
  }
}

/** Start a level transition (fade out → load → fade in) */
function startTransition(toLevel) {
  nextLevelIndex = toLevel;
  transitionTimer = 60;  // 30 frames fade-out + 30 frames fade-in
  transitionPhase = "fadeOut";
}

// =============================================================================
// COLLISION DETECTION
// =============================================================================

/**
 * Axis-Aligned Bounding Box (AABB) overlap check.
 * Returns true if two rectangles overlap.
 */
function rectsOverlap(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

/**
 * Resolve collisions between the player and all platforms.
 * Uses the player's velocity to determine which side they hit from.
 */
function handlePlatformCollisions() {
  player.onGround = false;

  for (const plat of activePlatforms) {
    if (!rectsOverlap(player, plat)) continue;

    // Calculate how far the player has penetrated into the platform from each side
    const overlapBottom = (player.y + player.height) - plat.y;
    const overlapTop = (plat.y + plat.height) - player.y;
    const overlapRight = (player.x + player.width) - plat.x;
    const overlapLeft = (plat.x + plat.width) - player.x;

    // Find the smallest overlap — that's the side we should resolve
    const minOverlap = Math.min(overlapBottom, overlapTop, overlapRight, overlapLeft);

    if (minOverlap === overlapBottom && player.velY >= 0) {
      // Landing on top of a platform
      player.y = plat.y - player.height;
      player.velY = 0;
      player.onGround = true;
    } else if (minOverlap === overlapTop && player.velY < 0) {
      // Hitting the underside of a platform
      player.y = plat.y + plat.height;
      player.velY = 0;
    } else if (minOverlap === overlapRight) {
      // Hitting the left side of a platform
      player.x = plat.x - player.width;
      player.velX = 0;
    } else if (minOverlap === overlapLeft) {
      // Hitting the right side of a platform
      player.x = plat.x + plat.width;
      player.velX = 0;
    }
  }
}

// =============================================================================
// ENEMY LOGIC
// =============================================================================

function updateEnemies() {
  for (const enemy of activeEnemies) {
    // Decrement invincibility timer
    if (enemy.invincibleTimer > 0) enemy.invincibleTimer--;

    // Move in the current direction
    enemy.x += enemy.speed * enemy.direction;

    // Reverse when hitting patrol boundaries
    if (enemy.x <= enemy.minX) {
      enemy.x = enemy.minX;
      enemy.direction = 1;
    } else if (enemy.x + enemy.width >= enemy.maxX) {
      enemy.x = enemy.maxX - enemy.width;
      enemy.direction = -1;
    }

    // Check if the player is touching this enemy
    if (rectsOverlap(player, enemy) && player.invincibleTimer === 0) {
      damagePlayer(1);
      return;
    }
  }
}

function drawEnemies() {
  const cols = 2, rows = 3;

  for (const enemy of activeEnemies) {
    const screenX = enemy.x - camera.x;
    const screenY = enemy.y - camera.y;

    // Flash during invincibility (skip draw every other 4-frame block)
    if (enemy.invincibleTimer > 0 && Math.floor(enemy.invincibleTimer / 4) % 2 === 0) {
      continue;
    }

    const chunkW = enemy.width / cols;
    const chunkH = enemy.height / rows;

    // Count fully-destroyed bottom rows so remaining chunks settle downward
    let dropRows = 0;
    if (enemy.destroyedChunks && enemy.destroyedChunks.length > 0) {
      for (let r = rows - 1; r >= 0; r--) {
        let rowGone = true;
        for (let c = 0; c < cols; c++) {
          if (!enemy.destroyedChunks.includes(r * cols + c)) { rowGone = false; break; }
        }
        if (rowGone) dropRows++; else break;
      }
    }
    const dropY = dropRows * chunkH;

    if (assets.enemy.loaded) {
      const img = assets.enemy.img;
      const srcChunkW = img.naturalWidth / cols;
      const srcChunkH = img.naturalHeight / rows;

      ctx.save();
      if (enemy.direction === -1) {
        ctx.translate(screenX + enemy.width, screenY + dropY);
        ctx.scale(-1, 1);
      }

      for (let idx = 0; idx < cols * rows; idx++) {
        if (enemy.destroyedChunks && enemy.destroyedChunks.includes(idx)) continue;
        const col = idx % cols;
        const row = Math.floor(idx / cols);
        const dx = enemy.direction === -1 ? col * chunkW : screenX + col * chunkW;
        const dy = enemy.direction === -1 ? row * chunkH : screenY + row * chunkH + dropY;

        ctx.drawImage(img,
          col * srcChunkW, row * srcChunkH, srcChunkW, srcChunkH,
          dx, dy, chunkW, chunkH);
      }
      ctx.restore();
    } else {
      // Fallback: colored rectangle chunks (face details omitted for destruction look)
      for (let idx = 0; idx < cols * rows; idx++) {
        if (enemy.destroyedChunks && enemy.destroyedChunks.includes(idx)) continue;
        const col = idx % cols;
        const row = Math.floor(idx / cols);
        ctx.fillStyle = enemy.color;
        ctx.fillRect(screenX + col * chunkW, screenY + row * chunkH + dropY, chunkW, chunkH);
      }
    }
  }
}

// =============================================================================
// BOSS LOGIC
// =============================================================================

function updateBoss() {
  if (!activeBoss || !activeBoss.alive) return;

  // Decrease invincibility timer
  if (activeBoss.invincibleTimer > 0) {
    activeBoss.invincibleTimer--;
  }

  // Boss walk animation
  if (assets.boss.frames.length > 1) {
    if (!activeBoss.animFrame) activeBoss.animFrame = 0;
    if (!activeBoss.animTimer) activeBoss.animTimer = 0;
    activeBoss.animTimer++;
    if (activeBoss.animTimer >= 16) {
      activeBoss.animTimer = 0;
      activeBoss.animFrame = (activeBoss.animFrame + 1) % assets.boss.frames.length;
    }
  }

  // Speed increases as HP drops
  const hpRatio = activeBoss.hp / activeBoss.maxHp;
  const currentSpeed = activeBoss.speed * (1 + (1 - hpRatio) * 1.2);

  // Patrol back and forth
  activeBoss.x += currentSpeed * activeBoss.direction;

  if (activeBoss.x <= activeBoss.minX) {
    activeBoss.x = activeBoss.minX;
    activeBoss.direction = 1;
  } else if (activeBoss.x + activeBoss.width >= activeBoss.maxX) {
    activeBoss.x = activeBoss.maxX - activeBoss.width;
    activeBoss.direction = -1;
  }

  // ---- Gravity & vertical movement ----
  activeBoss.velY += GRAVITY;
  if (activeBoss.velY > MAX_FALL_SPEED) activeBoss.velY = MAX_FALL_SPEED;
  activeBoss.y += activeBoss.velY;
  activeBoss.onGround = false;

  // Boss platform collisions
  for (const plat of activePlatforms) {
    if (!rectsOverlap(activeBoss, plat)) continue;
    const overlapBottom = (activeBoss.y + activeBoss.height) - plat.y;
    const overlapTop = (plat.y + plat.height) - activeBoss.y;
    if (overlapBottom < overlapTop && activeBoss.velY >= 0) {
      activeBoss.y = plat.y - activeBoss.height;
      activeBoss.velY = 0;
      activeBoss.onGround = true;
    }
  }

  // ---- Occasional jumping ----
  activeBoss.jumpTimer--;
  if (activeBoss.jumpTimer <= 0 && activeBoss.onGround) {
    activeBoss.velY = BOSS_JUMP_FORCE;
    activeBoss.onGround = false;
    activeBoss.jumpTimer = BOSS_JUMP_INTERVAL_MIN +
      Math.floor(Math.random() * (BOSS_JUMP_INTERVAL_MAX - BOSS_JUMP_INTERVAL_MIN));
  }

  // ---- Occasional shooting ----
  activeBoss.shootTimer--;
  if (activeBoss.shootTimer <= 0) {
    // Fire a red blaster toward the player
    const bx = activeBoss.x + activeBoss.width / 2;
    const by = activeBoss.y + activeBoss.height / 2;
    const dx = player.x + player.width / 2 - bx;
    const dy = player.y + player.height / 2 - by;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    bossProjectiles.push({
      x: bx - 4,
      y: by - 4,
      velX: (dx / dist) * BOSS_BLASTER_SPEED,
      velY: (dy / dist) * BOSS_BLASTER_SPEED,
      age: 0,
    });
    activeBoss.shootTimer = BOSS_SHOOT_INTERVAL_MIN +
      Math.floor(Math.random() * (BOSS_SHOOT_INTERVAL_MAX - BOSS_SHOOT_INTERVAL_MIN));
  }

  // Check collision with player
  if (rectsOverlap(player, activeBoss)) {
    if (activeBoss.invincibleTimer > 0) {
      return;
    }

    // Stomp check: player is falling and their bottom is near the boss's top
    const playerBottom = player.y + player.height;
    const bossTop = activeBoss.y;
    const stompZone = 20;

    if (player.velY > 0 && playerBottom - bossTop < stompZone) {
      // Successful stomp!
      activeBoss.hp--;
      activeBoss.invincibleTimer = 60;
      player.velY = JUMP_FORCE * 0.7;
      const stompDestroyed = pickRandomChunks(activeBoss, 1, 16);
      spawnChunkDebris(activeBoss, stompDestroyed, 4, 4, "boss");

      if (activeBoss.hp <= 0) {
        spawnDeathExplosion(activeBoss, 4, 4, "boss");
        activeBoss.alive = false;
        victoryScreen = true;
        playSound("boss_death");
      } else {
        playSound("boss_hit");
      }
    } else if (player.invincibleTimer === 0) {
      damagePlayer(1);
    }
  }
}

// =============================================================================
// BOSS PROJECTILE LOGIC
// =============================================================================

function updateBossProjectiles() {
  for (let i = bossProjectiles.length - 1; i >= 0; i--) {
    const bp = bossProjectiles[i];
    bp.age++;
    bp.x += bp.velX;
    bp.y += bp.velY;

    // Remove if off-screen
    if (bp.x < camera.x - 50 || bp.x > camera.x + canvas.width + 50 ||
        bp.y < -50 || bp.y > canvas.height + 50) {
      bossProjectiles.splice(i, 1);
      continue;
    }

    // Check collision with player
    if (player.invincibleTimer === 0 && rectsOverlap(
      { x: bp.x, y: bp.y, width: 8, height: 8 },
      player
    )) {
      damagePlayer(1);
      bossProjectiles.splice(i, 1);
    }
  }
}

function drawBossProjectiles() {
  for (const bp of bossProjectiles) {
    const screenX = bp.x - camera.x;
    const screenY = bp.y - camera.y;
    const cx = screenX + 4;
    const cy = screenY + 4;

    // Red glow
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = "#dc2626";
    ctx.beginPath();
    ctx.ellipse(cx, cy, 8, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Red blaster body
    ctx.fillStyle = "#dc2626";
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI * 2);
    ctx.fill();

    // Bright core
    ctx.fillStyle = "#fca5a5";
    ctx.beginPath();
    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawBoss() {
  if (!activeBoss || !activeBoss.alive) return;

  const screenX = activeBoss.x - camera.x;
  const screenY = activeBoss.y - camera.y;

  // Flash during invincibility (skip drawing every other frame)
  if (activeBoss.invincibleTimer > 0 && Math.floor(activeBoss.invincibleTimer / 4) % 2 === 0) {
    // Draw health bar even when flashing
    drawBossHealthBar(screenX, screenY);
    return;
  }

  const bCols = 4, bRows = 4;
  const bChunkW = activeBoss.width / bCols;
  const bChunkH = activeBoss.height / bRows;

  // Count fully-destroyed bottom rows so remaining chunks settle downward
  let dropRows = 0;
  if (activeBoss.destroyedChunks && activeBoss.destroyedChunks.length > 0) {
    for (let r = bRows - 1; r >= 0; r--) {
      let rowGone = true;
      for (let c = 0; c < bCols; c++) {
        if (!activeBoss.destroyedChunks.includes(r * bCols + c)) { rowGone = false; break; }
      }
      if (rowGone) dropRows++; else break;
    }
  }
  const dropY = dropRows * bChunkH;

  // Pick current animation frame for boss
  const bImg = assets.boss.frames.length > 1 ? assets.boss.frames[activeBoss.animFrame || 0] : (assets.boss.loaded ? assets.boss.img : null);

  if (bImg) {
    const srcChunkW = bImg.naturalWidth / bCols;
    const srcChunkH = bImg.naturalHeight / bRows;

    ctx.save();
    if (activeBoss.direction === -1) {
      ctx.translate(screenX + activeBoss.width, screenY + dropY);
      ctx.scale(-1, 1);
    }

    for (let idx = 0; idx < bCols * bRows; idx++) {
      if (activeBoss.destroyedChunks && activeBoss.destroyedChunks.includes(idx)) continue;
      const col = idx % bCols;
      const row = Math.floor(idx / bCols);
      const dx = activeBoss.direction === -1 ? col * bChunkW : screenX + col * bChunkW;
      const dy = activeBoss.direction === -1 ? row * bChunkH : screenY + row * bChunkH + dropY;

      ctx.drawImage(bImg,
        col * srcChunkW, row * srcChunkH, srcChunkW, srcChunkH,
        dx, dy, bChunkW, bChunkH);
    }
    ctx.restore();
  } else {
    // Fallback: colored rectangle chunks
    for (let idx = 0; idx < bCols * bRows; idx++) {
      if (activeBoss.destroyedChunks && activeBoss.destroyedChunks.includes(idx)) continue;
      const col = idx % bCols;
      const row = Math.floor(idx / bCols);
      ctx.fillStyle = activeBoss.color;
      ctx.fillRect(screenX + col * bChunkW, screenY + row * bChunkH + dropY, bChunkW, bChunkH);
    }
  }

  drawBossHealthBar(screenX, screenY);
}

function drawBossHealthBar(screenX, screenY) {
  if (!activeBoss) return;
  const barWidth = activeBoss.width;
  const barHeight = 8;
  const barY = screenY - 16;

  // Background
  ctx.fillStyle = "#333";
  ctx.fillRect(screenX, barY, barWidth, barHeight);
  // Health fill
  const fillWidth = (activeBoss.hp / activeBoss.maxHp) * barWidth;
  ctx.fillStyle = activeBoss.hp <= 1 ? "#dc2626" : "#ef4444";
  ctx.fillRect(screenX, barY, fillWidth, barHeight);
  // Border
  ctx.strokeStyle = "#111";
  ctx.lineWidth = 1;
  ctx.strokeRect(screenX, barY, barWidth, barHeight);
}

// =============================================================================
// SECRET DOOR LOGIC
// =============================================================================

function spawnDoorDebris(door) {
  const pieces = [];
  const count = 4 + Math.floor(Math.random() * 3);
  for (let i = 0; i < count; i++) {
    const pw = 6 + Math.random() * 8;
    const ph = 6 + Math.random() * 8;
    pieces.push({
      x: door.x + Math.random() * door.width,
      y: door.y + Math.random() * door.height,
      pw: pw, ph: ph,
      sfx: Math.random(), sfy: Math.random(),
      sfw: pw / door.width, sfh: ph / door.height,
      velX: (Math.random() - 0.5) * 6,
      velY: -(2 + Math.random() * 4),
      rot: 0,
      rotSpeed: (Math.random() - 0.5) * 0.4,
    });
  }
  deathEffects.push({
    width: door.width, height: door.height,
    color: "#8b5e3c",
    direction: 1,
    assetKey: "secretDoor",
    pieces: pieces,
    timer: 30, maxTimer: 30,
  });
}

function updateSecretDoor() {
  if (!secretDoor) return;
  if (secretDoor.hpBarTimer > 0) secretDoor.hpBarTimer--;

  // Broken door acts as portal
  if (secretDoor.broken && transitionTimer === 0) {
    if (rectsOverlap(player, secretDoor)) {
      startTransition(2);
    }
  }
}

function drawSecretDoor() {
  if (!secretDoor) return;

  const screenX = secretDoor.x - camera.x;
  const screenY = secretDoor.y - camera.y;

  if (secretDoor.broken) {
    // Portal glow effect
    const pulse = Math.sin(portalAnimTimer) * 0.3 + 0.7;
    ctx.save();
    ctx.globalAlpha = pulse * 0.4;
    ctx.fillStyle = "#a78bfa";
    ctx.beginPath();
    ctx.ellipse(
      screenX + secretDoor.width / 2,
      screenY + secretDoor.height / 2,
      secretDoor.width / 2 + 10,
      secretDoor.height / 2 + 10,
      0, 0, Math.PI * 2
    );
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    if (assets.secretDoorBroken.loaded) {
      ctx.save();
      ctx.globalAlpha = 0.7 + pulse * 0.3;
      ctx.drawImage(assets.secretDoorBroken.img, screenX, screenY, secretDoor.width, secretDoor.height);
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalAlpha = 0.7 + pulse * 0.3;
      ctx.fillStyle = "#6b3fa0";
      ctx.fillRect(screenX, screenY, secretDoor.width, secretDoor.height);
      ctx.restore();
    }
  } else {
    // Normal door
    if (assets.secretDoor.loaded) {
      ctx.drawImage(assets.secretDoor.img, screenX, screenY, secretDoor.width, secretDoor.height);
    } else {
      ctx.fillStyle = "#8b5e3c";
      ctx.fillRect(screenX, screenY, secretDoor.width, secretDoor.height);
      // Door details
      ctx.fillStyle = "#6b4226";
      ctx.fillRect(screenX + 4, screenY + 4, secretDoor.width - 8, secretDoor.height - 8);
      ctx.fillStyle = "#d4a574";
      ctx.fillRect(screenX + secretDoor.width - 14, screenY + secretDoor.height / 2 - 3, 6, 6);
    }
  }

  // Health bar (visible while taking damage)
  if (secretDoor.hpBarTimer > 0 && !secretDoor.broken) {
    const barWidth = secretDoor.width;
    const barHeight = 4;
    const barY = screenY - 8;
    const alpha = secretDoor.hpBarTimer < 30 ? secretDoor.hpBarTimer / 30 : 1;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "#333";
    ctx.fillRect(screenX, barY, barWidth, barHeight);
    const fillWidth = (secretDoor.hp / secretDoor.maxHp) * barWidth;
    ctx.fillStyle = "#ef4444";
    ctx.fillRect(screenX, barY, fillWidth, barHeight);
    ctx.restore();
  }
}

// =============================================================================
// SECRET LEVEL LOGIC
// =============================================================================

const SECRET_CHOICE_BUTTONS = [
  { label: "Take Sword", x: 100, y: 360, width: 180, height: 40 },
  { label: "Don't take sword", x: 310, y: 360, width: 180, height: 40 },
  { label: "I am feeling special", x: 520, y: 360, width: 180, height: 40 },
];

function updateSecretLevel() {
  if (!secretLevelState) return;
  const st = secretLevelState;
  const npc = st.npc;

  // Animate cave background
  if (assets.secretCave.frames.length > 1) {
    secretCaveAnimTimer++;
    if (secretCaveAnimTimer >= 16) {
      secretCaveAnimTimer = 0;
      secretCaveAnimFrame = (secretCaveAnimFrame + 1) % assets.secretCave.frames.length;
    }
  }

  if (st.phase === "walk") {
    // NPC paces on right side
    npc.animTimer++;
    if (npc.animTimer >= 9) { // 150ms at 60fps
      npc.animTimer = 0;
      npc.animFrame = (npc.animFrame + 1) % Math.max(1, assets.poodle.frames.length);
    }

    // Player approaches NPC → switch to talk
    const dist = Math.abs(player.x + player.width / 2 - (npc.x + npc.width / 2));
    if (dist < 120) {
      st.phase = "talk";
      st.dialogueTimer = 0;
      st.dialogueChars = 0;
      npc.animFrame = 0;
      npc.animTimer = 0;
      npc.facing = player.x < npc.x ? -1 : 1;
    }
  }

  else if (st.phase === "talk") {
    // NPC talk animation
    npc.animTimer++;
    if (npc.animTimer >= 7) { // 120ms at 60fps
      npc.animTimer = 0;
      npc.animFrame = (npc.animFrame + 1) % Math.max(1, assets.poodleTalk.frames.length);
    }

    // Typewriter effect
    st.dialogueTimer++;
    if (st.dialogueTimer % 3 === 0 && st.dialogueChars < st.fullDialogue.length) {
      st.dialogueChars++;
    }

    // All text shown → advance to sword phase
    if (st.dialogueChars >= st.fullDialogue.length && st.dialogueTimer > st.fullDialogue.length * 3 + 60) {
      st.phase = "sword";
      playSound("sword_appear");
    }
  }

  else if (st.phase === "sword") {
    // NPC stays in talk idle
    npc.animTimer++;
    if (npc.animTimer >= 16) {
      npc.animTimer = 0;
      npc.animFrame = (npc.animFrame + 1) % Math.max(1, assets.poodleTalk.frames.length);
    }

    // Sword floats down
    if (st.swordY < st.swordTargetY) {
      st.swordY += 1.5;
      if (st.swordY > st.swordTargetY) st.swordY = st.swordTargetY;
    }

    // Animate sword
    if (assets.sword.frames.length > 1) {
      st.swordAnimTimer++;
      if (st.swordAnimTimer >= 12) {
        st.swordAnimTimer = 0;
        st.swordAnimFrame = (st.swordAnimFrame + 1) % assets.sword.frames.length;
      }
    }

    // Sword reached target → show choices
    if (st.swordY >= st.swordTargetY) {
      st.phase = "choice";
    }
  }

  else if (st.phase === "choice") {
    // Sword bob animation
    st.swordAnimTimer++;
    if (assets.sword.frames.length > 1 && st.swordAnimTimer % 12 === 0) {
      st.swordAnimFrame = (st.swordAnimFrame + 1) % assets.sword.frames.length;
    }

    // NPC idle
    npc.animTimer++;
    if (npc.animTimer >= 16) {
      npc.animTimer = 0;
      npc.animFrame = (npc.animFrame + 1) % Math.max(1, assets.poodleTalk.frames.length);
    }

    if (st.choiceMade !== null) {
      if (st.choiceMade === 0) {
        // Take Sword
        hasSword = true;
      } else if (st.choiceMade === 1) {
        // Don't take sword — no changes
      } else if (st.choiceMade === 2) {
        // I am feeling special
        hasSword = true;
        isPoodle = true;
        poodleMode = true;
      }
      st.phase = "exit";
      st.exitTimer = 60;
    }
  }

  else if (st.phase === "exit") {
    st.exitTimer--;
    if (st.exitTimer <= 0) {
      startTransition(0);
      st.phase = "done";
    }
  }
}

function drawSecretLevel() {
  if (!secretLevelState) return;
  const st = secretLevelState;
  const npc = st.npc;

  // Draw NPC
  const npcScreenX = npc.x - camera.x;
  const npcScreenY = npc.y - camera.y;

  const useTalkAnim = (st.phase === "talk" || st.phase === "sword" || st.phase === "choice" || st.phase === "exit" || st.phase === "done");
  const npcAsset = useTalkAnim ? assets.poodleTalk : assets.poodle;
  const npcFrames = npcAsset.frames;
  const npcFrame = npcFrames.length > 0 ? npcFrames[npc.animFrame % npcFrames.length] : null;

  if (npcFrame) {
    ctx.save();
    if (npc.facing === -1) {
      ctx.translate(npcScreenX + npc.width, npcScreenY);
      ctx.scale(-1, 1);
      ctx.drawImage(npcFrame, 0, 0, npc.width, npc.height);
    } else {
      ctx.drawImage(npcFrame, npcScreenX, npcScreenY, npc.width, npc.height);
    }
    ctx.restore();
  } else if (npcAsset.loaded) {
    ctx.save();
    if (npc.facing === -1) {
      ctx.translate(npcScreenX + npc.width, npcScreenY);
      ctx.scale(-1, 1);
      ctx.drawImage(npcAsset.img, 0, 0, npc.width, npc.height);
    } else {
      ctx.drawImage(npcAsset.img, npcScreenX, npcScreenY, npc.width, npc.height);
    }
    ctx.restore();
  } else {
    // Fallback: pink rectangle poodle
    ctx.fillStyle = "#f9a8d4";
    ctx.fillRect(npcScreenX, npcScreenY, npc.width, npc.height);
    ctx.fillStyle = "#333";
    ctx.font = "10px monospace";
    ctx.textAlign = "center";
    ctx.fillText("Poodle", npcScreenX + npc.width / 2, npcScreenY + npc.height / 2);
    ctx.textAlign = "left";
  }

  // Draw dialogue bubble
  if ((st.phase === "talk" || st.phase === "sword" || st.phase === "choice") && st.dialogueChars > 0) {
    const text = st.fullDialogue.substring(0, st.dialogueChars);
    const bubbleX = npcScreenX - 80;
    const bubbleW = 220;

    // Word-wrap text into lines (never split mid-word)
    ctx.font = "11px monospace";
    const maxW = bubbleW - 16;
    const words = text.split(" ");
    const lines = [];
    let curLine = "";
    for (const word of words) {
      const testLine = curLine ? curLine + " " + word : word;
      if (ctx.measureText(testLine).width > maxW && curLine) {
        lines.push(curLine);
        curLine = word;
      } else {
        curLine = testLine;
      }
    }
    if (curLine) lines.push(curLine);

    const lineH = 13;
    const bubbleH = Math.max(36, lines.length * lineH + 14);
    const bubbleY = npcScreenY - bubbleH - 14;

    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.roundRect(bubbleX, bubbleY, bubbleW, bubbleH, 8);
    ctx.fill();
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(bubbleX, bubbleY, bubbleW, bubbleH, 8);
    ctx.stroke();

    ctx.fillStyle = "#222";
    ctx.textAlign = "left";
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], bubbleX + 8, bubbleY + 14 + i * lineH);
    }
  }

  // Draw floating sword
  if (st.phase === "sword" || st.phase === "choice" || st.phase === "exit") {
    const swordW = 32;
    const swordH = 48;
    const swordX = canvas.width / 2 - swordW / 2;
    const bob = Math.sin(Date.now() / 400) * 4;

    const swordAsset = assets.sword;
    const swordFrame = swordAsset.frames.length > 0 ? swordAsset.frames[st.swordAnimFrame % swordAsset.frames.length] : null;

    // Glow
    ctx.save();
    ctx.globalAlpha = 0.3 + Math.sin(Date.now() / 300) * 0.15;
    ctx.fillStyle = "#fbbf24";
    ctx.beginPath();
    ctx.ellipse(swordX + swordW / 2, st.swordY + bob + swordH / 2, swordW / 2 + 10, swordH / 2 + 10, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();

    if (swordFrame) {
      ctx.drawImage(swordFrame, swordX, st.swordY + bob, swordW, swordH);
    } else if (swordAsset.loaded) {
      ctx.drawImage(swordAsset.img, swordX, st.swordY + bob, swordW, swordH);
    } else {
      // Fallback: yellow sword shape
      ctx.fillStyle = "#fbbf24";
      ctx.fillRect(swordX + swordW / 2 - 3, st.swordY + bob, 6, swordH - 10);
      ctx.fillStyle = "#8b6914";
      ctx.fillRect(swordX + swordW / 2 - 10, st.swordY + bob + swordH - 14, 20, 6);
      ctx.fillRect(swordX + swordW / 2 - 4, st.swordY + bob + swordH - 10, 8, 10);
    }
  }

  // Draw choice buttons
  if (st.phase === "choice" && st.choiceMade === null) {
    for (const btn of SECRET_CHOICE_BUTTONS) {
      // Button background
      ctx.fillStyle = "rgba(30, 30, 60, 0.85)";
      ctx.beginPath();
      ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 6);
      ctx.fill();

      // Button border
      ctx.strokeStyle = "#a78bfa";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(btn.x, btn.y, btn.width, btn.height, 6);
      ctx.stroke();

      // Button text
      ctx.fillStyle = "#e2e8f0";
      ctx.font = "bold 13px monospace";
      ctx.textAlign = "center";
      ctx.fillText(btn.label, btn.x + btn.width / 2, btn.y + btn.height / 2 + 5);
      ctx.textAlign = "left";
    }
  }

  // Exit message
  if (st.phase === "exit" || st.phase === "done") {
    ctx.fillStyle = "rgba(0,0,0,0.4)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#fbbf24";
    ctx.font = "bold 24px monospace";
    ctx.textAlign = "center";
    if (hasSword && isPoodle) {
      ctx.fillText("You feel... special!", canvas.width / 2, canvas.height / 2);
    } else if (hasSword) {
      ctx.fillText("You got the sword!", canvas.width / 2, canvas.height / 2);
    } else {
      ctx.fillText("Maybe next time...", canvas.width / 2, canvas.height / 2);
    }
    ctx.textAlign = "left";
  }
}

// =============================================================================
// PORTAL LOGIC
// =============================================================================

let portalAnimTimer = 0;

function updatePortal() {
  if (!activePortal) return;
  portalAnimTimer += 0.05;

  // Check if player overlaps portal
  if (rectsOverlap(player, activePortal) && transitionTimer === 0) {
    startTransition(currentLevel + 1);
  }
}

function drawPortal() {
  if (!activePortal) return;

  const screenX = activePortal.x - camera.x;
  const screenY = activePortal.y - camera.y;
  const pulse = Math.sin(portalAnimTimer) * 0.3 + 0.7; // Oscillates between 0.4 and 1.0

  // Glow effect
  ctx.save();
  ctx.globalAlpha = pulse * 0.4;
  ctx.fillStyle = "#a78bfa";
  ctx.beginPath();
  ctx.ellipse(
    screenX + activePortal.width / 2,
    screenY + activePortal.height / 2,
    activePortal.width / 2 + 12,
    activePortal.height / 2 + 12,
    0, 0, Math.PI * 2
  );
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();

  if (assets.portal.loaded) {
    ctx.save();
    ctx.globalAlpha = 0.7 + pulse * 0.3;
    ctx.drawImage(assets.portal.img, screenX, screenY, activePortal.width, activePortal.height);
    ctx.restore();
  } else {
    // Fallback: glowing oval
    ctx.save();
    ctx.globalAlpha = 0.7 + pulse * 0.3;

    // Outer ring
    ctx.strokeStyle = "#c084fc";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.ellipse(
      screenX + activePortal.width / 2,
      screenY + activePortal.height / 2,
      activePortal.width / 2,
      activePortal.height / 2,
      0, 0, Math.PI * 2
    );
    ctx.stroke();

    // Inner fill
    const gradient = ctx.createRadialGradient(
      screenX + activePortal.width / 2, screenY + activePortal.height / 2, 5,
      screenX + activePortal.width / 2, screenY + activePortal.height / 2, activePortal.width / 2
    );
    gradient.addColorStop(0, "rgba(167, 139, 250, 0.8)");
    gradient.addColorStop(0.6, "rgba(139, 92, 246, 0.5)");
    gradient.addColorStop(1, "rgba(109, 40, 217, 0.1)");
    ctx.fillStyle = gradient;
    ctx.fill();

    ctx.restore();
  }
}

// =============================================================================
// PROJECTILE LOGIC
// =============================================================================

function updateProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const p = projectiles[i];
    p.age++;

    // Store trail position (last 3 positions)
    p.trail.push({ x: p.x, y: p.y });
    if (p.trail.length > 3) p.trail.shift();

    // Move projectile + subtle wobble
    p.x += p.velX;
    p.y += (p.velY || 0) + Math.sin(p.age * 0.3) * 0.5;

    // Remove if off-screen
    if (p.x < camera.x - 50 || p.x > camera.x + canvas.width + 50 ||
        p.y < -50 || p.y > canvas.height + 50) {
      projectiles.splice(i, 1);
      continue;
    }

    // Check collision with enemies
    let hit = false;
    for (let e = activeEnemies.length - 1; e >= 0; e--) {
      const enemy = activeEnemies[e];
      if (enemy.invincibleTimer > 0) continue;
      if (rectsOverlap(
        { x: p.x, y: p.y, width: PROJECTILE_SIZE, height: PROJECTILE_SIZE },
        enemy
      )) {
        enemy.hp--;
        if (enemy.hp <= 0) {
          spawnDeathExplosion(enemy, 2, 3, "enemy");
          activeEnemies.splice(e, 1);
          playSound("enemy_death");
        } else {
          const destroyed = pickRandomChunks(enemy, 2, 6);
          spawnChunkDebris(enemy, destroyed, 2, 3, "enemy");
          enemy.invincibleTimer = 15;
          playSound("enemy_hit");
        }
        projectiles.splice(i, 1);
        hit = true;
        break;
      }
    }
    if (hit) continue;

    // Check collision with secret door
    if (secretDoor && !secretDoor.broken) {
      if (rectsOverlap(
        { x: p.x, y: p.y, width: PROJECTILE_SIZE, height: PROJECTILE_SIZE },
        secretDoor
      )) {
        secretDoor.hp--;
        secretDoor.hpBarTimer = 90;
        spawnDoorDebris(secretDoor);
        if (secretDoor.hp <= 0) {
          secretDoor.broken = true;
          playSound("enemy_death");
        } else {
          playSound("enemy_hit");
        }
        projectiles.splice(i, 1);
        hit = true;
      }
    }
    if (hit) continue;

    // Check collision with boss
    if (activeBoss && activeBoss.alive && activeBoss.invincibleTimer === 0) {
      if (rectsOverlap(
        { x: p.x, y: p.y, width: PROJECTILE_SIZE, height: PROJECTILE_SIZE },
        activeBoss
      )) {
        activeBoss.hp--;
        activeBoss.invincibleTimer = 60;
        const bossDestroyed = pickRandomChunks(activeBoss, 1, 16);
        spawnChunkDebris(activeBoss, bossDestroyed, 4, 4, "boss");
        projectiles.splice(i, 1);

        if (activeBoss.hp <= 0) {
          spawnDeathExplosion(activeBoss, 4, 4, "boss");
          activeBoss.alive = false;
          victoryScreen = true;
          playSound("boss_death");
        } else {
          playSound("boss_hit");
        }
      }
    }
  }
}

function drawProjectiles() {
  const laserLen = 22;
  const laserH = 6;

  for (const p of projectiles) {
    const screenX = p.x - camera.x;
    const screenY = p.y - camera.y;
    const cx = screenX + PROJECTILE_SIZE / 2;
    const cy = screenY + PROJECTILE_SIZE / 2;
    const angle = p.angle || 0;

    // Trail: fading rotated laser afterimages
    for (let t = 0; t < p.trail.length; t++) {
      const tr = p.trail[t];
      const trCx = tr.x - camera.x + PROJECTILE_SIZE / 2;
      const trCy = tr.y - camera.y + PROJECTILE_SIZE / 2;
      const alpha = (t + 1) / (p.trail.length + 1) * 0.3;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(trCx, trCy);
      ctx.rotate(angle);
      ctx.fillStyle = "#fbbf24";
      ctx.fillRect(-laserLen / 2, -laserH / 4, laserLen, laserH / 2);
      ctx.restore();
    }

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(angle);

    // Outer glow
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = "#fbbf24";
    ctx.beginPath();
    ctx.ellipse(0, 0, laserLen / 2 + 4, laserH / 2 + 4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Laser body (golden)
    ctx.fillStyle = "#fbbf24";
    const r = laserH / 2;
    ctx.beginPath();
    ctx.moveTo(-laserLen / 2 + r, -r);
    ctx.lineTo(laserLen / 2 - r, -r);
    ctx.arc(laserLen / 2 - r, 0, r, -Math.PI / 2, Math.PI / 2);
    ctx.lineTo(-laserLen / 2 + r, r);
    ctx.arc(-laserLen / 2 + r, 0, r, Math.PI / 2, -Math.PI / 2);
    ctx.closePath();
    ctx.fill();

    // Bright white core
    ctx.fillStyle = "white";
    const coreH = laserH * 0.35;
    const cr = coreH / 2;
    ctx.beginPath();
    ctx.moveTo(-laserLen / 3 + cr, -cr);
    ctx.lineTo(laserLen / 3 - cr, -cr);
    ctx.arc(laserLen / 3 - cr, 0, cr, -Math.PI / 2, Math.PI / 2);
    ctx.lineTo(-laserLen / 3 + cr, cr);
    ctx.arc(-laserLen / 3 + cr, 0, cr, Math.PI / 2, -Math.PI / 2);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
}

// =============================================================================
// BEAM WEAPON (sword equipped)
// =============================================================================

const BEAM_LENGTH = 300;
const BEAM_WIDTH = 16;
const BEAM_DAMAGE_INTERVAL = 10; // Frames between damage ticks

function updateBeam() {
  if (!player.beamActive) { beamDamageTimer = 0; return; }

  beamDamageTimer++;
  if (beamDamageTimer < BEAM_DAMAGE_INTERVAL) return;
  beamDamageTimer = 0;

  // Beam origin: sword tip (top-center of sword) when equipped
  const swordW = 32, swordH = 64;
  const handX = player.facing === 1 ? player.width - 12 : 12 - swordW;
  const cx = player.x + handX + swordW / 2;
  const cy = player.y + (-swordH + 24); // sword tip (top of sword)
  const cos = Math.cos(player.beamAngle);
  const sin = Math.sin(player.beamAngle);

  // Check enemies
  for (let e = activeEnemies.length - 1; e >= 0; e--) {
    const enemy = activeEnemies[e];
    if (enemy.invincibleTimer > 0) continue;
    if (beamHitsRect(cx, cy, cos, sin, BEAM_LENGTH, BEAM_WIDTH, enemy)) {
      enemy.hp--;
      if (enemy.hp <= 0) {
        spawnDeathExplosion(enemy, 2, 3, "enemy");
        activeEnemies.splice(e, 1);
        playSound("enemy_death");
      } else {
        const destroyed = pickRandomChunks(enemy, 2, 6);
        spawnChunkDebris(enemy, destroyed, 2, 3, "enemy");
        enemy.invincibleTimer = 15;
        playSound("enemy_hit");
      }
    }
  }

  // Check boss
  if (activeBoss && activeBoss.alive && activeBoss.invincibleTimer === 0) {
    if (beamHitsRect(cx, cy, cos, sin, BEAM_LENGTH, BEAM_WIDTH, activeBoss)) {
      activeBoss.hp--;
      activeBoss.invincibleTimer = 60;
      const bossDestroyed = pickRandomChunks(activeBoss, 1, 16);
      spawnChunkDebris(activeBoss, bossDestroyed, 4, 4, "boss");

      if (activeBoss.hp <= 0) {
        spawnDeathExplosion(activeBoss, 4, 4, "boss");
        activeBoss.alive = false;
        victoryScreen = true;
        playSound("boss_death");
      } else {
        playSound("boss_hit");
      }
    }
  }

  // Check secret door
  if (secretDoor && !secretDoor.broken) {
    if (beamHitsRect(cx, cy, cos, sin, BEAM_LENGTH, BEAM_WIDTH, secretDoor)) {
      secretDoor.hp--;
      secretDoor.hpBarTimer = 90;
      spawnDoorDebris(secretDoor);
      if (secretDoor.hp <= 0) {
        secretDoor.broken = true;
        playSound("enemy_death");
      } else {
        playSound("enemy_hit");
      }
    }
  }
}

function beamHitsRect(ox, oy, cos, sin, length, width, rect) {
  // Sample points along beam and check if any fall inside rect
  const steps = 8;
  const halfW = width / 2;
  for (let i = 0; i <= steps; i++) {
    const t = (i / steps) * length;
    const px = ox + cos * t;
    const py = oy + sin * t;
    // Expand check by beam half-width
    if (px + halfW > rect.x && px - halfW < rect.x + rect.width &&
        py + halfW > rect.y && py - halfW < rect.y + rect.height) {
      return true;
    }
  }
  return false;
}

function drawBeam() {
  if (!player.beamActive) return;

  // Beam draws from sword tip
  const swordW = 32, swordH = 64;
  const handX = player.facing === 1 ? player.width - 12 : 12 - swordW;
  const cx = player.x - camera.x + handX + swordW / 2;
  const cy = player.y - camera.y + (-swordH + 24);
  const angle = player.beamAngle;
  const pulse = 0.7 + Math.sin(Date.now() / 80) * 0.3;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(angle);

  // Outer glow
  ctx.globalAlpha = 0.25 * pulse;
  ctx.fillStyle = "#fbbf24";
  ctx.fillRect(0, -BEAM_WIDTH, BEAM_LENGTH, BEAM_WIDTH * 2);

  // Main beam
  ctx.globalAlpha = 0.7 * pulse;
  ctx.fillStyle = "#f59e0b";
  ctx.fillRect(0, -BEAM_WIDTH / 2, BEAM_LENGTH, BEAM_WIDTH);

  // Core
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "#fef3c7";
  ctx.fillRect(0, -BEAM_WIDTH / 4, BEAM_LENGTH, BEAM_WIDTH / 2);

  ctx.restore();
}

// =============================================================================
// ENEMY DEATH EFFECT
// =============================================================================

/** Pick random intact chunks from an entity's grid and mark them destroyed */
function pickRandomChunks(entity, count, totalChunks) {
  if (!entity.destroyedChunks) entity.destroyedChunks = [];
  // Cap destruction at 50% of total chunks — keeps sprite recognizable until death
  const maxDestroyed = Math.floor(totalChunks * 0.5);
  const remaining = maxDestroyed - entity.destroyedChunks.length;
  if (remaining <= 0) return [];
  const effectiveCount = Math.min(count, remaining);
  const intact = [];
  for (let i = 0; i < totalChunks; i++) {
    if (!entity.destroyedChunks.includes(i)) intact.push(i);
  }
  const picked = [];
  for (let i = 0; i < effectiveCount && intact.length > 0; i++) {
    const idx = Math.floor(Math.random() * intact.length);
    picked.push(intact.splice(idx, 1)[0]);
  }
  entity.destroyedChunks.push(...picked);
  return picked;
}

/** Spawn small debris particles when chunks are destroyed (non-fatal hit) */
function spawnChunkDebris(entity, chunkIndices, cols, rows, assetKey) {
  const chunkW = entity.width / cols;
  const chunkH = entity.height / rows;
  const centerX = entity.x + entity.width / 2;
  const centerY = entity.y + entity.height / 2;
  const pieces = [];

  for (const idx of chunkIndices) {
    const col = idx % cols;
    const row = Math.floor(idx / cols);
    const px = entity.x + col * chunkW;
    const py = entity.y + row * chunkH;
    const dx = px + chunkW / 2 - centerX;
    const dy = py + chunkH / 2 - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;

    const count = 3 + Math.floor(Math.random() * 2);
    for (let i = 0; i < count; i++) {
      const subW = chunkW * (0.3 + Math.random() * 0.4);
      const subH = chunkH * (0.3 + Math.random() * 0.4);
      pieces.push({
        x: px + Math.random() * (chunkW - subW),
        y: py + Math.random() * (chunkH - subH),
        pw: subW, ph: subH,
        sfx: (col + Math.random() * 0.5) / cols,
        sfy: (row + Math.random() * 0.5) / rows,
        sfw: subW / entity.width,
        sfh: subH / entity.height,
        velX: (dx / dist) * (2 + Math.random() * 3) + (Math.random() - 0.5) * 2,
        velY: -(2 + Math.random() * 3),
        rot: 0,
        rotSpeed: (Math.random() - 0.5) * 0.4,
      });
    }
  }

  deathEffects.push({
    width: entity.width,
    height: entity.height,
    color: entity.color,
    direction: entity.direction,
    assetKey: assetKey,
    pieces: pieces,
    timer: 30,
    maxTimer: 30,
  });
}

/** Spawn a big explosion when an entity dies — remaining chunks fly off */
function spawnDeathExplosion(entity, cols, rows, assetKey) {
  const chunkW = entity.width / cols;
  const chunkH = entity.height / rows;
  const totalChunks = cols * rows;
  const centerX = entity.x + entity.width / 2;
  const centerY = entity.y + entity.height / 2;
  if (!entity.destroyedChunks) entity.destroyedChunks = [];

  const pieces = [];
  for (let idx = 0; idx < totalChunks; idx++) {
    if (entity.destroyedChunks.includes(idx)) continue;
    const col = idx % cols;
    const row = Math.floor(idx / cols);
    const px = entity.x + col * chunkW;
    const py = entity.y + row * chunkH;
    const dx = px + chunkW / 2 - centerX;
    const dy = py + chunkH / 2 - centerY;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;

    // Main chunk piece
    pieces.push({
      x: px, y: py, pw: chunkW, ph: chunkH,
      sfx: col / cols, sfy: row / rows,
      sfw: 1 / cols, sfh: 1 / rows,
      velX: (dx / dist) * (4 + Math.random() * 3) + (Math.random() - 0.5) * 2,
      velY: -(4 + Math.random() * 4),
      rot: 0,
      rotSpeed: (Math.random() - 0.5) * 0.3,
    });

    // 2-3 tiny sub-particles per chunk
    const subCount = 2 + Math.floor(Math.random() * 2);
    for (let s = 0; s < subCount; s++) {
      const subW = chunkW * 0.3;
      const subH = chunkH * 0.3;
      pieces.push({
        x: px + Math.random() * chunkW,
        y: py + Math.random() * chunkH,
        pw: subW, ph: subH,
        sfx: col / cols, sfy: row / rows,
        sfw: 0.3 / cols, sfh: 0.3 / rows,
        velX: (dx / dist) * (3 + Math.random() * 4) + (Math.random() - 0.5) * 4,
        velY: -(3 + Math.random() * 5),
        rot: 0,
        rotSpeed: (Math.random() - 0.5) * 0.5,
      });
    }
  }

  deathEffects.push({
    width: entity.width,
    height: entity.height,
    color: entity.color,
    direction: entity.direction,
    assetKey: assetKey,
    pieces: pieces,
    timer: 60,
    maxTimer: 60,
  });
}

function updateDeathEffects() {
  for (let i = deathEffects.length - 1; i >= 0; i--) {
    const eff = deathEffects[i];
    eff.timer--;

    for (const piece of eff.pieces) {
      piece.x += piece.velX;
      piece.y += piece.velY;
      piece.velY += GRAVITY * 0.8; // Gravity on pieces
      piece.rot += piece.rotSpeed;
    }

    if (eff.timer <= 0) {
      deathEffects.splice(i, 1);
    }
  }
}

function drawDeathEffects() {
  for (const eff of deathEffects) {
    const alpha = eff.timer < 15 ? eff.timer / 15 : 1;

    for (const piece of eff.pieces) {
      const screenX = piece.x - camera.x;
      const screenY = piece.y - camera.y;

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.translate(screenX + piece.pw / 2, screenY + piece.ph / 2);
      ctx.rotate(piece.rot);

      const effAsset = eff.assetKey ? assets[eff.assetKey] : assets.enemy;
      if (effAsset && effAsset.loaded) {
        const img = effAsset.img;

        ctx.save();
        if (eff.direction === -1) {
          ctx.scale(-1, 1);
        }
        ctx.drawImage(
          img,
          piece.sfx * img.width,              // source x
          piece.sfy * img.height,             // source y
          piece.sfw * img.width,              // source width
          piece.sfh * img.height,             // source height
          -piece.pw / 2, -piece.ph / 2,      // dest position (centered)
          piece.pw, piece.ph                  // dest size
        );
        ctx.restore();
      } else {
        ctx.fillStyle = eff.color;
        ctx.fillRect(-piece.pw / 2, -piece.ph / 2, piece.pw, piece.ph);
      }

      ctx.restore();
    }
  }
}

// =============================================================================
// DEATH & RESTART
// =============================================================================

let deathMessage = "";
let deathTimer = 0;

function damagePlayer(amount) {
  if (transitionTimer > 0 || victoryScreen) return;
  if (player.invincibleTimer > 0) return;

  player.hp -= amount;
  player.invincibleTimer = PLAYER_INVINCIBLE_TIME;
  player.hpBarTimer = PLAYER_HP_BAR_DURATION;
  playSound("player_hit");

  if (player.hp <= 0) {
    player.hp = 0;
    die();
  }
}

function die() {
  if (transitionTimer > 0 || victoryScreen) return;
  deathMessage = "You died! Restarting...";
  deathTimer = 90;
  loadLevel(currentLevel);
}

// =============================================================================
// TRANSITION LOGIC
// =============================================================================

function updateTransition() {
  if (transitionTimer <= 0) return;

  transitionTimer--;

  if (transitionPhase === "fadeOut" && transitionTimer === 30) {
    // Midpoint: load the next level
    loadLevel(nextLevelIndex);
    transitionPhase = "fadeIn";
  }

  if (transitionTimer === 0) {
    transitionPhase = "";
  }
}

function drawTransition() {
  if (transitionTimer <= 0) return;

  let alpha;
  if (transitionPhase === "fadeOut") {
    // Fading out: alpha goes from 0 to 1 over 30 frames
    alpha = 1 - (transitionTimer - 30) / 30;
  } else {
    // Fading in: alpha goes from 1 to 0 over 30 frames
    alpha = transitionTimer / 30;
  }

  ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// =============================================================================
// DRAWING HELPERS
// =============================================================================

/**
 * Draw the background using the current level's background image.
 * The image tiles horizontally and scrolls with a parallax factor so it
 * moves slower than the foreground, creating depth. Falls back to a
 * gradient if the image didn't load.
 */
const BG_PARALLAX = 0.25; // Background scrolls at 25% of camera speed

function drawBackground() {
  const bgKey = levels[currentLevel].backgroundKey;
  const bgAsset = assets[bgKey];

  if (bgAsset && bgAsset.loaded) {
    // Animated background for secret cave
    if (bgKey === "secretCave" && bgAsset.frames && bgAsset.frames.length > 1) {
      const frame = bgAsset.frames[secretCaveAnimFrame % bgAsset.frames.length];
      ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
      return;
    }

    const bgImg = bgAsset.img;

    // Scale the image to fill the canvas height, preserving aspect ratio
    const scale = canvas.height / bgImg.height;
    const bgWidth = bgImg.width * scale;
    const bgHeight = canvas.height;

    // Calculate the parallax offset and wrap it so the image tiles seamlessly
    const offset = -(camera.x * BG_PARALLAX) % bgWidth;

    // Draw enough copies to cover the full canvas width
    // Start one bgWidth to the left to handle the wrap-around
    for (let x = offset - bgWidth; x < canvas.width; x += bgWidth) {
      ctx.drawImage(bgImg, x, 0, bgWidth, bgHeight);
    }
  } else {
    // Fallback: sky gradient (different per level)
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    if (currentLevel === 1) {
      // Dark cave gradient
      gradient.addColorStop(0, "#1a1a2e");
      gradient.addColorStop(1, "#2d1b4e");
    } else if (currentLevel === 2) {
      // Secret cave gradient
      gradient.addColorStop(0, "#1a0a2e");
      gradient.addColorStop(1, "#3d1b6e");
    } else {
      gradient.addColorStop(0, "#87ceeb");
      gradient.addColorStop(1, SKY_COLOR);
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

/** Draw background decorations with parallax scrolling */
function drawDecorations() {
  for (const dec of activeDecorations) {
    // Parallax: decorations scroll slower than the foreground
    const screenX = dec.x - camera.x * dec.parallax;
    const screenY = dec.y;
    ctx.fillStyle = dec.color;

    if (dec.type === "stalactite") {
      // Stalactite: triangle hanging from ceiling
      ctx.beginPath();
      ctx.moveTo(screenX, screenY);
      ctx.lineTo(screenX + dec.width, screenY);
      ctx.lineTo(screenX + dec.width / 2, screenY + dec.height);
      ctx.closePath();
      ctx.fill();
    } else if (dec.type === "crystal") {
      // Crystal: diamond shape with glow
      const cx = screenX + dec.width / 2;
      const cy = screenY + dec.height / 2;
      // Glow
      ctx.save();
      ctx.globalAlpha = 0.3 + Math.sin(portalAnimTimer * 2 + dec.x) * 0.2;
      ctx.fillStyle = dec.color;
      ctx.beginPath();
      ctx.ellipse(cx, cy, dec.width, dec.height, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
      // Diamond
      ctx.fillStyle = dec.color;
      ctx.beginPath();
      ctx.moveTo(cx, screenY);
      ctx.lineTo(screenX + dec.width, cy);
      ctx.lineTo(cx, screenY + dec.height);
      ctx.lineTo(screenX, cy);
      ctx.closePath();
      ctx.fill();
    } else if (dec.y < 150) {
      // Cloud: draw a rounded blob
      ctx.beginPath();
      ctx.ellipse(
        screenX + dec.width / 2,
        screenY + dec.height / 2,
        dec.width / 2,
        dec.height / 2,
        0, 0, Math.PI * 2
      );
      ctx.fill();
    } else {
      // Bush: simple rounded rectangle
      const r = 10;
      ctx.beginPath();
      ctx.moveTo(screenX + r, screenY);
      ctx.lineTo(screenX + dec.width - r, screenY);
      ctx.quadraticCurveTo(screenX + dec.width, screenY, screenX + dec.width, screenY + r);
      ctx.lineTo(screenX + dec.width, screenY + dec.height);
      ctx.lineTo(screenX, screenY + dec.height);
      ctx.lineTo(screenX, screenY + r);
      ctx.quadraticCurveTo(screenX, screenY, screenX + r, screenY);
      ctx.fill();
    }
  }
}

function drawPlatforms() {
  for (const plat of activePlatforms) {
    const screenX = plat.x - camera.x;
    const screenY = plat.y - camera.y;

    // Skip platforms entirely off-screen for performance
    if (screenX + plat.width < 0 || screenX > canvas.width) continue;

    ctx.fillStyle = plat.color;
    ctx.fillRect(screenX, screenY, plat.width, plat.height);

    if (currentLevel === 0) {
      // Level 1: maroon/crimson theme
      if (plat.height <= 20) {
        ctx.fillStyle = "#a85555";
        ctx.fillRect(screenX, screenY, plat.width, 4);
      } else {
        ctx.fillStyle = "#8b4040";
        ctx.fillRect(screenX, screenY, plat.width, 6);
      }
    } else {
      // Level 2: cave/brown theme
      if (plat.height <= 20) {
        ctx.fillStyle = "#8b6f54";
        ctx.fillRect(screenX, screenY, plat.width, 4);
      } else {
        ctx.fillStyle = "#7a6652";
        ctx.fillRect(screenX, screenY, plat.width, 6);
      }
    }
  }
}

/** Draw the HUD (level indicator, death message, controls hint) */
function drawHUD() {
  // Death message
  if (deathTimer > 0) {
    deathTimer--;
    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#ff6b6b";
    ctx.font = "bold 28px monospace";
    ctx.textAlign = "center";
    ctx.fillText(deathMessage, canvas.width / 2, canvas.height / 2);
    ctx.textAlign = "left";
  }

  // Victory screen
  if (victoryScreen) {
    ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#fbbf24";
    ctx.font = "bold 40px monospace";
    ctx.textAlign = "center";
    ctx.fillText("You Win!", canvas.width / 2, canvas.height / 2 - 20);

    ctx.fillStyle = "white";
    ctx.font = "20px monospace";
    ctx.fillText("Press R to Restart", canvas.width / 2, canvas.height / 2 + 30);
    ctx.textAlign = "left";
  }

  // Level indicator (top-right)
  ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
  ctx.fillRect(canvas.width - 100, 8, 92, 28);
  ctx.fillStyle = "white";
  ctx.font = "bold 14px monospace";
  ctx.textAlign = "right";
  ctx.fillText(currentLevel === 2 ? "Secret!" : `Level ${currentLevel + 1}`, canvas.width - 16, 27);
  ctx.textAlign = "left";

  // Controls hint (top-left)
  ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
  ctx.fillRect(8, 8, 400, 28);
  ctx.fillStyle = "white";
  ctx.font = "13px monospace";
  ctx.fillText("Arrows: Move | Up/Space: Jump | < > Aim | Shift: Shoot", 14, 27);

  // Secret "DO NOT PRESS" button
  if (corvetteMode) {
    ctx.fillStyle = "rgba(0, 100, 0, 0.7)";
    ctx.fillRect(8, 42, 120, 24);
    ctx.fillStyle = "#66ff66";
    ctx.font = "bold 11px monospace";
    ctx.fillText("ACTIVATED", 16, 58);
  } else {
    ctx.fillStyle = "rgba(100, 0, 0, 0.7)";
    ctx.fillRect(8, 42, 120, 24);
    ctx.fillStyle = "#ffcccc";
    ctx.font = "bold 11px monospace";
    ctx.fillText("DO NOT PRESS", 14, 58);
  }

  // Player health bar (only visible after being hit, fades out)
  if (player.hpBarTimer > 0) {
    const barWidth = 80;
    const barHeight = 6;
    const screenX = player.x - camera.x + (player.width - barWidth) / 2;
    const screenY = player.y - camera.y - 14;

    // Fade out over the last 60 frames
    const alpha = player.hpBarTimer < 60 ? player.hpBarTimer / 60 : 1;

    ctx.save();
    ctx.globalAlpha = alpha;

    // Background
    ctx.fillStyle = "#333";
    ctx.fillRect(screenX, screenY, barWidth, barHeight);
    // Health fill
    const fillWidth = (player.hp / player.maxHp) * barWidth;
    ctx.fillStyle = player.hp <= player.maxHp * 0.25 ? "#dc2626" :
                    player.hp <= player.maxHp * 0.5 ? "#f59e0b" : "#22c55e";
    ctx.fillRect(screenX, screenY, fillWidth, barHeight);
    // Border
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 1;
    ctx.strokeRect(screenX, screenY, barWidth, barHeight);

    ctx.restore();
  }
}

// =============================================================================
// RESTART (R key for victory screen)
// =============================================================================

window.addEventListener("keydown", (e) => {
  if (e.code === "KeyR" && victoryScreen) {
    hasSword = false;
    isPoodle = false;
    poodleMode = false;
    secretLevelState = null;
    loadLevel(0);
  }
});

// =============================================================================
// SECRET BUTTON — canvas click handler
// =============================================================================

canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const cx = (e.clientX - rect.left) * scaleX;
  const cy = (e.clientY - rect.top) * scaleY;

  // Secret level choice buttons
  if (secretLevelState && secretLevelState.phase === "choice" && secretLevelState.choiceMade === null) {
    for (let i = 0; i < SECRET_CHOICE_BUTTONS.length; i++) {
      const btn = SECRET_CHOICE_BUTTONS[i];
      if (cx >= btn.x && cx <= btn.x + btn.width && cy >= btn.y && cy <= btn.y + btn.height) {
        secretLevelState.choiceMade = i;
        playSound("jump");
        return;
      }
    }
  }

  // Button region: drawn at (8, 42), size 120x24
  if (cx >= 8 && cx <= 128 && cy >= 42 && cy <= 66) {
    corvetteMode = !corvetteMode;
  }
});

// =============================================================================
// MAIN GAME LOOP
// =============================================================================

function gameLoop() {
  // 1. Update game state
  updateTransition();

  if (transitionTimer === 0 && !victoryScreen) {
    player.update();
    handlePlatformCollisions();
    updateEnemies();
    updateBoss();
    updateBossProjectiles();
    updateProjectiles();
    updateBeam();
    updateDeathEffects();
    updatePortal();
    if (currentLevel === 0) updateSecretDoor();
    if (currentLevel === 2) updateSecretLevel();
  }

  camera.follow(player);

  // 2. Draw everything (order matters: back to front)
  drawBackground();
  drawDecorations();
  drawPlatforms();
  drawPortal();
  if (currentLevel === 0) drawSecretDoor();
  drawEnemies();
  drawBoss();
  drawBossProjectiles();
  drawProjectiles();
  drawBeam();
  drawDeathEffects();
  player.draw();
  if (currentLevel === 2) drawSecretLevel();
  drawHUD();
  drawTransition();

  // 3. Request the next frame
  requestAnimationFrame(gameLoop);
}

// Load assets, then start the game
loadAllAssets();
  </script>
</body>
</html>
